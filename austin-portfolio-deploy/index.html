<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#002244">

    <title>🔥 Blaze Intelligence: Championship Visual Experience | Deep South Sports Authority</title>
    <meta name="description" content="Broadcast-quality sports intelligence platform with cinema-grade 3D graphics and premium UI design.">

    <!-- Preconnect for Performance -->
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>

    <!-- Premium Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Oswald:wght@300;400;500;600;700&family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css">

    <!-- Revolutionary 3D & Animation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r158/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/examples/js/shaders/ColorCorrectionShader.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lottie-web/5.12.2/lottie.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <!-- 🎬 UNREAL ENGINE 5.5 INTEGRATION - Cinema-Quality Rendering Pipeline -->
    <script src="unreal-engine-module.js"></script>

    <!-- Championship Dashboard Integration - Blaze Intelligence MCP -->
    <script src="championship-dashboard-integration.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>

    <!-- 🏆 CHAMPIONSHIP 60FPS PERFORMANCE OPTIMIZATION SYSTEM -->
    <script src="championship-60fps-optimization-engine.js"></script>
    <script src="championship-webgl-shader-optimizer.js"></script>
    <script src="championship-memory-optimizer.js"></script>
    <script src="championship-performance-master.js"></script>

    <!-- Revolutionary Command Center System -->
    <link rel="stylesheet" href="css/blaze-revolutionary-command-center.css">
    <script src="js/blaze-revolutionary-command-center.js"></script>

    <style>
        /* ===== CHAMPIONSHIP COLOR SYSTEM ===== */
        :root {
            /* Primary Deep South Palette */
            --burnt-orange: #BF5700;
            --burnt-orange-light: #FF7A00;
            --burnt-orange-glow: rgba(191, 87, 0, 0.4);
            --sec-crimson: #9E1B32;
            --sec-crimson-light: #C73E1D;
            --titans-navy: #002244;
            --titans-navy-light: #003366;
            --field-green: #2D5016;
            --field-green-light: #3D6B1F;

            /* Championship Accents */
            --championship-gold: #FFD700;
            --championship-gold-light: #FFED4E;
            --platinum: #E5E4E2;
            --texas-brown: #3F2A14;
            --stadium-lights: #FFF8DC;

            /* Premium Glass System */
            --glass-primary: rgba(0, 34, 68, 0.15);
            --glass-secondary: rgba(191, 87, 0, 0.1);
            --glass-accent: rgba(158, 27, 50, 0.12);
            --glass-border: rgba(255, 255, 255, 0.15);
            --glass-border-strong: rgba(255, 255, 255, 0.25);

            /* Advanced Shadows */
            --shadow-premium: 0 20px 40px rgba(0, 0, 0, 0.3),
                             0 8px 16px rgba(0, 0, 0, 0.2),
                             inset 0 1px 0 rgba(255, 255, 255, 0.1);
            --shadow-deep: 0 32px 64px rgba(0, 0, 0, 0.4);
            --shadow-glow-orange: 0 0 20px var(--burnt-orange-glow);

            /* Typography Scale */
            --font-hero: clamp(3rem, 8vw, 6rem);
            --font-display: clamp(2rem, 5vw, 4rem);
            --font-heading: clamp(1.5rem, 4vw, 2.5rem);
            --font-body: clamp(1rem, 2vw, 1.125rem);
            --font-caption: clamp(0.875rem, 1.5vw, 1rem);

            /* Animation Easing */
            --ease-premium: cubic-bezier(0.25, 0.8, 0.25, 1);
            --ease-bounce: cubic-bezier(0.68, -0.55, 0.265, 1.55);
            --ease-slow: cubic-bezier(0.23, 1, 0.32, 1);

            /* Spacing System */
            --space-xs: clamp(0.5rem, 2vw, 0.75rem);
            --space-sm: clamp(0.75rem, 3vw, 1rem);
            --space-md: clamp(1rem, 4vw, 1.5rem);
            --space-lg: clamp(1.5rem, 5vw, 2rem);
            --space-xl: clamp(2rem, 6vw, 3rem);
            --space-xxl: clamp(3rem, 8vw, 4rem);
        }

        /* ===== FOUNDATION RESET ===== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        *::before,
        *::after {
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* ===== PREMIUM BODY SYSTEM ===== */
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            font-weight: 400;
            line-height: 1.6;
            color: var(--stadium-lights);
            background: #000;
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
        }

        /* ===== CINEMATIC BACKGROUND SYSTEM ===== */
        .premium-background {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -3;
            background:
                radial-gradient(ellipse at top, var(--titans-navy) 0%, #000 70%),
                linear-gradient(135deg,
                    rgba(191, 87, 0, 0.1) 0%,
                    rgba(0, 34, 68, 0.3) 25%,
                    rgba(45, 80, 22, 0.2) 50%,
                    rgba(158, 27, 50, 0.1) 75%,
                    #000 100%
                );
        }

        /* Revolutionary Command Center Canvas */
        #command-center-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: -1;
            pointer-events: none;
        }

        /* Advanced Particle Canvas */
        .particle-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -2;
            opacity: 0.6;
            pointer-events: none;
        }

        /* Stadium Lighting System */
        .stadium-lights {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
            opacity: 0.4;
            background:
                radial-gradient(circle at 15% 25%, var(--burnt-orange-glow) 0%, transparent 50%),
                radial-gradient(circle at 85% 75%, rgba(158, 27, 50, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 50% 10%, rgba(255, 215, 0, 0.2) 0%, transparent 30%);
            animation: stadiumFlicker 8s ease-in-out infinite alternate;
        }

        @keyframes stadiumFlicker {
            0%, 100% { opacity: 0.4; }
            25% { opacity: 0.6; }
            50% { opacity: 0.3; }
            75% { opacity: 0.5; }
        }

        /* ===== PREMIUM HEADER SYSTEM ===== */
        .championship-header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--glass-primary);
            backdrop-filter: blur(24px) saturate(1.8);
            border-bottom: 2px solid var(--glass-border-strong);
            box-shadow: var(--shadow-premium);
            padding: var(--space-md) var(--space-lg);
            transition: all 0.4s var(--ease-premium);
        }

        .championship-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                var(--burnt-orange) 25%,
                var(--championship-gold) 50%,
                var(--sec-crimson) 75%,
                transparent 100%
            );
        }

        .header-content {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: var(--space-md);
        }

        .logo-premium {
            display: flex;
            align-items: center;
            gap: var(--space-md);
            text-decoration: none;
            color: inherit;
            transition: transform 0.3s var(--ease-premium);
        }

        .logo-premium:hover {
            transform: translateY(-2px);
        }

        .logo-icon-premium {
            width: 64px;
            height: 64px;
            background: linear-gradient(135deg,
                var(--burnt-orange) 0%,
                var(--championship-gold) 50%,
                var(--sec-crimson) 100%
            );
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: var(--shadow-glow-orange);
            position: relative;
            overflow: hidden;
        }

        .logo-icon-premium::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent,
                rgba(255, 255, 255, 0.4),
                transparent
            );
            transition: left 0.6s var(--ease-premium);
        }

        .logo-icon-premium:hover::before {
            left: 100%;
        }

        .logo-icon-premium i {
            font-size: 28px;
            color: white;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }

        .logo-text {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .brand-title {
            font-family: 'Oswald', sans-serif;
            font-size: var(--font-heading);
            font-weight: 700;
            background: linear-gradient(135deg,
                var(--stadium-lights) 0%,
                var(--championship-gold) 50%,
                var(--burnt-orange-light) 100%
            );
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            line-height: 1;
        }

        .brand-subtitle {
            font-size: var(--font-caption);
            font-weight: 500;
            color: var(--platinum);
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* ===== PREMIUM NAVIGATION ===== */
        .nav-premium {
            display: flex;
            gap: var(--space-md);
            align-items: center;
        }

        .nav-item {
            position: relative;
            padding: var(--space-sm) var(--space-md);
            background: var(--glass-secondary);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            color: var(--stadium-lights);
            text-decoration: none;
            font-weight: 500;
            font-size: var(--font-body);
            transition: all 0.3s var(--ease-premium);
            overflow: hidden;
        }

        .nav-item::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 100%;
            background: linear-gradient(135deg, var(--burnt-orange), var(--sec-crimson));
            transition: width 0.4s var(--ease-premium);
            z-index: -1;
        }

        .nav-item:hover::before {
            width: 100%;
        }

        .nav-item:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-premium);
            border-color: var(--glass-border-strong);
        }

        /* ===== HERO SECTION ===== */
        .hero-premium {
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            padding: var(--space-xxl) var(--space-lg);
        }

        .hero-content {
            max-width: 1200px;
            text-align: center;
            z-index: 10;
            position: relative;
        }

        .hero-badge {
            display: inline-block;
            padding: var(--space-sm) var(--space-md);
            background: var(--glass-accent);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border);
            border-radius: 50px;
            font-size: var(--font-caption);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--championship-gold);
            margin-bottom: var(--space-lg);
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .hero-title {
            font-family: 'Oswald', sans-serif;
            font-size: var(--font-hero);
            font-weight: 700;
            line-height: 1.1;
            margin-bottom: var(--space-lg);
            background: linear-gradient(135deg,
                var(--stadium-lights) 0%,
                var(--championship-gold) 25%,
                var(--burnt-orange-light) 50%,
                var(--sec-crimson-light) 75%,
                var(--stadium-lights) 100%
            );
            background-size: 300% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            animation: titleShimmer 4s ease-in-out infinite;
        }

        @keyframes titleShimmer {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .hero-subtitle {
            font-size: var(--font-heading);
            font-weight: 300;
            color: var(--platinum);
            margin-bottom: var(--space-xl);
            opacity: 0.9;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
        }

        /* ===== PREMIUM DASHBOARD GRID ===== */
        .dashboard-grid {
            max-width: 1400px;
            margin: 0 auto;
            padding: var(--space-xxl) var(--space-lg);
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: var(--space-xl);
        }

        .dashboard-card {
            background: var(--glass-primary);
            backdrop-filter: blur(24px) saturate(1.5);
            border: 1px solid var(--glass-border);
            border-radius: 24px;
            padding: var(--space-xl);
            box-shadow: var(--shadow-premium);
            transition: all 0.4s var(--ease-premium);
            position: relative;
            overflow: hidden;
        }

        .dashboard-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(90deg,
                var(--burnt-orange) 0%,
                var(--championship-gold) 50%,
                var(--sec-crimson) 100%
            );
        }

        .dashboard-card:hover {
            transform: translateY(-8px);
            box-shadow: var(--shadow-deep);
            border-color: var(--glass-border-strong);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: var(--space-lg);
        }

        .card-title {
            font-family: 'Oswald', sans-serif;
            font-size: var(--font-heading);
            font-weight: 600;
            color: var(--stadium-lights);
        }

        .card-icon {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, var(--burnt-orange), var(--sec-crimson));
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 24px;
        }

        /* ===== PREMIUM METRICS DISPLAY ===== */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: var(--space-md);
            margin-top: var(--space-lg);
        }

        .metric-item {
            text-align: center;
            padding: var(--space-md);
            background: var(--glass-secondary);
            border: 1px solid var(--glass-border);
            border-radius: 16px;
            transition: all 0.3s var(--ease-premium);
        }

        .metric-item:hover {
            transform: scale(1.05);
            background: var(--glass-accent);
        }

        .metric-value {
            display: block;
            font-family: 'JetBrains Mono', monospace;
            font-size: var(--font-display);
            font-weight: 700;
            color: var(--championship-gold);
            line-height: 1;
            margin-bottom: var(--space-sm);
        }

        .metric-label {
            font-size: var(--font-caption);
            color: var(--platinum);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-weight: 500;
        }

        /* ===== COMMAND CENTER LAUNCH BUTTON ===== */
        .hero-actions {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: var(--space-lg);
            margin-top: var(--space-xl);
        }

        .command-center-btn {
            position: relative;
            padding: 16px 32px;
            background: linear-gradient(135deg, var(--burnt-orange), var(--burnt-orange-light));
            border: 2px solid var(--championship-gold);
            border-radius: 50px;
            color: white;
            font-family: 'Inter', sans-serif;
            font-weight: 700;
            font-size: 18px;
            letter-spacing: 0.5px;
            text-transform: uppercase;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.4s var(--ease-premium);
            box-shadow:
                0 8px 32px rgba(191, 87, 0, 0.4),
                0 0 40px rgba(255, 215, 0, 0.3);
            transform: translateY(0);
        }

        .command-center-btn:hover {
            transform: translateY(-3px);
            box-shadow:
                0 16px 64px rgba(191, 87, 0, 0.6),
                0 0 60px rgba(255, 215, 0, 0.5);
            border-color: var(--championship-gold-light);
        }

        .command-center-btn i {
            margin-right: 12px;
            font-size: 20px;
        }

        .btn-glow {
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent,
                rgba(255, 255, 255, 0.3),
                transparent
            );
            transition: left 0.6s var(--ease-premium);
        }

        .command-center-btn:hover .btn-glow {
            left: 100%;
        }

        .hero-status {
            display: flex;
            align-items: center;
            gap: 12px;
            font-size: 14px;
            color: var(--platinum);
            opacity: 0.8;
        }

        .status-indicator {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: status-pulse 2s ease-in-out infinite;
        }

        .status-indicator.online {
            background: #00FF88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        /* ===== REVOLUTIONARY 3D STADIUM VISUALIZATION ===== */
        .stadium-3d-container {
            height: 600px;
            border-radius: 24px;
            overflow: hidden;
            position: relative;
            background: linear-gradient(135deg,
                rgba(0, 34, 68, 0.4) 0%,
                rgba(45, 80, 22, 0.3) 50%,
                rgba(0, 8, 20, 0.6) 100%
            );
            box-shadow:
                inset 0 0 100px rgba(0, 0, 0, 0.5),
                var(--shadow-deep);
        }

        .canvas-3d {
            width: 100%;
            height: 100%;
            border-radius: 24px;
            cursor: grab;
            transition: cursor 0.2s ease;
        }

        .canvas-3d:active {
            cursor: grabbing;
        }

        /* 3D Scene Controls */
        .scene-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-btn {
            width: 48px;
            height: 48px;
            background: var(--glass-primary);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border-strong);
            border-radius: 12px;
            color: var(--stadium-lights);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s var(--ease-premium);
            font-size: 18px;
        }

        .control-btn:hover {
            background: var(--burnt-orange);
            transform: scale(1.1);
            box-shadow: var(--shadow-glow-orange);
        }

        /* Performance Monitor */
        .performance-monitor {
            position: absolute;
            bottom: 20px;
            left: 20px;
            z-index: 100;
            display: flex;
            gap: 12px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 11px;
        }

        .perf-metric {
            padding: 6px 12px;
            background: var(--glass-primary);
            backdrop-filter: blur(8px);
            border: 1px solid var(--glass-border);
            border-radius: 8px;
            color: var(--championship-gold);
            min-width: 80px;
            text-align: center;
        }

        /* Sport Mode Indicator */
        .sport-indicator {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
            padding: 8px 16px;
            background: var(--glass-accent);
            backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border-strong);
            border-radius: 20px;
            color: var(--stadium-lights);
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            font-size: 14px;
        }

        /* Interactive Data Overlays */
        .data-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 50;
            background: var(--glass-primary);
            backdrop-filter: blur(20px);
            border: 1px solid var(--glass-border-strong);
            border-radius: 16px;
            padding: 20px;
            min-width: 200px;
            text-align: center;
            opacity: 0;
            transition: opacity 0.3s var(--ease-premium);
        }

        .data-overlay.active {
            opacity: 1;
        }

        /* Enhanced Canvas Container */
        .canvas-3d-container {
            height: 600px;
            border-radius: 24px;
            overflow: hidden;
            position: relative;
            background: linear-gradient(135deg,
                rgba(0, 34, 68, 0.4) 0%,
                rgba(45, 80, 22, 0.3) 50%,
                rgba(0, 8, 20, 0.6) 100%
            );
            box-shadow:
                inset 0 0 100px rgba(0, 0, 0, 0.5),
                var(--shadow-deep);
        }

        /* Stadium Lighting Effects */
        .stadium-floodlight {
            position: absolute;
            width: 8px;
            height: 8px;
            background: var(--championship-gold);
            border-radius: 50%;
            box-shadow: 0 0 20px var(--championship-gold);
            animation: floodlightFlicker 3s ease-in-out infinite;
        }

        @keyframes floodlightFlicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Responsive 3D Optimizations */
        @media (max-width: 768px) {
            .canvas-3d-container {
                height: 400px;
            }

            .scene-controls {
                top: 10px;
                right: 10px;
                gap: 8px;
            }

            .control-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }

            .performance-monitor {
                bottom: 10px;
                left: 10px;
                gap: 8px;
            }

            .perf-metric {
                padding: 4px 8px;
                font-size: 10px;
                min-width: 60px;
            }
        }

        /* ===== LOADING SYSTEM ===== */
        .premium-loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000 0%, var(--titans-navy) 50%, #000 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 9999;
            transition: opacity 1s var(--ease-slow), visibility 1s var(--ease-slow);
        }

        .premium-loader.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .loader-icon {
            width: 100px;
            height: 100px;
            background: linear-gradient(135deg, var(--burnt-orange), var(--championship-gold));
            border-radius: 50%;
            position: relative;
            margin-bottom: var(--space-lg);
            animation: loaderSpin 2s linear infinite;
        }

        @keyframes loaderSpin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loader-text {
            font-family: 'Oswald', sans-serif;
            font-size: var(--font-heading);
            font-weight: 600;
            color: var(--stadium-lights);
            text-align: center;
        }

        /* ===== RESPONSIVE SYSTEM ===== */
        @media (max-width: 768px) {
            .nav-premium {
                display: none;
            }

            .dashboard-grid {
                grid-template-columns: 1fr;
                gap: var(--space-lg);
                padding: var(--space-lg);
            }

            .hero-premium {
                min-height: 80vh;
                padding: var(--space-lg);
            }

            .metrics-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* ===== ACCESSIBILITY ENHANCEMENTS ===== */
        @media (prefers-reduced-motion: reduce) {
            *, *::before, *::after {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* Focus indicators */
        .nav-item:focus,
        .dashboard-card:focus {
            outline: 2px solid var(--championship-gold);
            outline-offset: 2px;
        }
    </style>
</head>
<body>
    <!-- Premium Loading Experience -->
    <div class="premium-loader" id="premiumLoader">
        <div class="loader-icon">
            <i class="fas fa-fire" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 40px; color: white;"></i>
        </div>
        <div class="loader-text">
            <div>🔥 BLAZE INTELLIGENCE</div>
            <div style="font-size: 1rem; margin-top: 0.5rem; opacity: 0.7;">Loading Championship Experience...</div>
        </div>
    </div>

    <!-- Cinematic Background System -->
    <div class="premium-background"></div>
    <canvas class="particle-canvas" id="particleCanvas"></canvas>
    <div class="stadium-lights"></div>

    <!-- Revolutionary Command Center Canvas -->
    <canvas id="command-center-canvas"></canvas>

    <!-- Championship Header -->
    <header class="championship-header">
        <div class="header-content">
            <a href="#" class="logo-premium">
                <div class="logo-icon-premium">
                    <i class="fas fa-fire"></i>
                </div>
                <div class="logo-text">
                    <div class="brand-title">BLAZE INTELLIGENCE</div>
                    <div class="brand-subtitle">The Deep South Sports Authority</div>
                </div>
            </a>

            <nav class="nav-premium">
                <a href="#" class="nav-item">Dashboard</a>
                <a href="#" class="nav-item">Analytics</a>
                <a href="#" class="nav-item">Teams</a>
                <a href="#" class="nav-item">Reports</a>
            </nav>
        </div>
    </header>

    <!-- Hero Section -->
    <section class="hero-premium">
        <div class="hero-content">
            <div class="hero-badge">Premium Visual Experience</div>
            <h1 class="hero-title">CHAMPIONSHIP-GRADE SPORTS INTELLIGENCE</h1>
            <p class="hero-subtitle">
                From Friday Night Lights to Sunday in the Show — experience broadcast-quality
                analytics with cinema-grade 3D graphics and premium user interface design.
            </p>
            <div class="hero-actions">
                <button id="launch-command-center" class="command-center-btn">
                    <i class="fas fa-rocket"></i>
                    <span>LAUNCH COMMAND CENTER</span>
                    <div class="btn-glow"></div>
                </button>
                <div class="hero-status">
                    <span class="status-indicator online"></span>
                    <span>Revolutionary 3D Interface Ready</span>
                </div>
            </div>
        </div>
    </section>

    <!-- Premium Dashboard -->
    <main class="dashboard-grid">
        <!-- Live Metrics Card -->
        <div class="dashboard-card">
            <div class="card-header">
                <h2 class="card-title">Live Championship Metrics</h2>
                <div class="card-icon">
                    <i class="fas fa-chart-line"></i>
                </div>
            </div>
            <div class="metrics-grid">
                <div class="metric-item">
                    <span class="metric-value" id="accuracyMetric">70.2%</span>
                    <span class="metric-label">Accuracy</span>
                </div>
                <div class="metric-item">
                    <span class="metric-value" id="teamsMetric">153</span>
                    <span class="metric-label">Teams</span>
                </div>
                <div class="metric-item">
                    <span class="metric-value" id="uptimeMetric">99.1%</span>
                    <span class="metric-label">Uptime</span>
                </div>
                <div class="metric-item">
                    <span class="metric-value" id="latencyMetric">89ms</span>
                    <span class="metric-label">Response</span>
                </div>
            </div>
        </div>

        <!-- Revolutionary 3D Stadium Visualization -->
        <div class="dashboard-card" style="grid-column: span 2;">
            <div class="card-header">
                <h2 class="card-title">Championship Stadium Experience</h2>
                <div class="card-icon">
                    <i class="fas fa-cube"></i>
                </div>
            </div>
            <div class="canvas-3d-container">
                <canvas class="canvas-3d" id="threeDCanvas"></canvas>

                <!-- Sport Mode Indicator -->
                <div class="sport-indicator" id="sportIndicator">
                    🏈 FOOTBALL MODE
                </div>

                <!-- 3D Scene Controls -->
                <div class="scene-controls">
                    <button class="control-btn" id="resetCameraBtn" title="Reset Camera View">
                        <i class="fas fa-home"></i>
                    </button>
                    <button class="control-btn" id="toggleLightingBtn" title="Toggle Stadium Lighting">
                        <i class="fas fa-lightbulb"></i>
                    </button>
                    <button class="control-btn" id="changeSportBtn" title="Change Sport Mode">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                    <button class="control-btn" id="fullscreenBtn" title="Enter Fullscreen">
                        <i class="fas fa-expand"></i>
                    </button>
                    <button class="control-btn" id="autoRotateBtn" title="Toggle Auto-Rotate">
                        <i class="fas fa-redo"></i>
                    </button>

                    <!-- 🎬 POST-PROCESSING CONTROLS -->
                    <button class="control-btn" id="togglePostProcessingBtn" title="Toggle Post-Processing Effects">
                        <i class="fas fa-magic"></i>
                    </button>
                    <button class="control-btn" id="toggleBloomBtn" title="Toggle Bloom Effect">
                        <i class="fas fa-star"></i>
                    </button>
                    <button class="control-btn" id="toggleChromaticBtn" title="Toggle Chromatic Aberration">
                        <i class="fas fa-rainbow"></i>
                    </button>

                    <!-- 🎬 CINEMATIC CONTROLS -->
                    <button class="control-btn" id="startCinematicBtn" title="Start Cinematic Camera Sequence">
                        <i class="fas fa-video"></i>
                    </button>

                    <!-- 🌩️ DYNAMIC WEATHER CONTROLS -->
                    <button class="control-btn" id="weatherClearBtn" title="Clear Weather">
                        <i class="fas fa-sun"></i>
                    </button>
                    <button class="control-btn" id="weatherRainBtn" title="Rain Weather">
                        <i class="fas fa-cloud-rain"></i>
                    </button>
                    <button class="control-btn" id="weatherSnowBtn" title="Snow Weather">
                        <i class="fas fa-snowflake"></i>
                    </button>
                    <button class="control-btn" id="weatherFogBtn" title="Fog Weather">
                        <i class="fas fa-smog"></i>
                    </button>
                    <button class="control-btn" id="weatherCycleBtn" title="Auto Weather Cycle">
                        <i class="fas fa-sync"></i>
                    </button>
                </div>

                <!-- Championship Performance Monitor -->
                <div class="performance-monitor">
                    <div class="perf-metric" id="fps-indicator">FPS: --</div>
                    <div class="perf-metric" id="memory-indicator">Memory: --</div>
                    <div class="perf-metric" id="quality-indicator">Quality: --</div>
                    <div class="perf-metric" id="performance-health">Health: --</div>
                </div>

                <!-- Interactive Data Overlay -->
                <div class="data-overlay" id="dataOverlay">
                    <div style="font-weight: 700; color: var(--championship-gold); margin-bottom: 8px;">
                        Championship Stats
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">
                        Click stadium elements for detailed analytics
                    </div>
                </div>

                <!-- Stadium Floodlights -->
                <div class="stadium-floodlight" style="top: 10%; left: 15%;"></div>
                <div class="stadium-floodlight" style="top: 10%; right: 15%;"></div>
                <div class="stadium-floodlight" style="bottom: 20%; left: 25%;"></div>
                <div class="stadium-floodlight" style="bottom: 20%; right: 25%;"></div>
            </div>
        </div>

        <!-- Team Performance Card -->
        <div class="dashboard-card">
            <div class="card-header">
                <h2 class="card-title">Championship Teams</h2>
                <div class="card-icon">
                    <i class="fas fa-trophy"></i>
                </div>
            </div>
            <div style="display: grid; gap: 1rem; margin-top: 1rem;">
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--glass-secondary); border-radius: 12px;">
                    <div>
                        <div style="font-weight: 600; color: var(--championship-gold);">⚾ Cardinals</div>
                        <div style="font-size: 0.875rem; opacity: 0.8;">MLB • St. Louis</div>
                    </div>
                    <div style="font-family: 'JetBrains Mono'; font-weight: 700; color: var(--burnt-orange);">76-80</div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--glass-secondary); border-radius: 12px;">
                    <div>
                        <div style="font-weight: 600; color: var(--championship-gold);">🏈 Titans</div>
                        <div style="font-size: 0.875rem; opacity: 0.8;">NFL • Tennessee</div>
                    </div>
                    <div style="font-family: 'JetBrains Mono'; font-weight: 700; color: var(--sec-crimson);">0-3</div>
                </div>
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 1rem; background: var(--glass-secondary); border-radius: 12px;">
                    <div>
                        <div style="font-weight: 600; color: var(--championship-gold);">🏈 Longhorns</div>
                        <div style="font-size: 0.875rem; opacity: 0.8;">NCAA • Texas</div>
                    </div>
                    <div style="font-family: 'JetBrains Mono'; font-weight: 700; color: var(--field-green-light);">#10</div>
                </div>
            </div>
        </div>

        <!-- NIL Valuation Calculator -->
        <div class="dashboard-card">
            <div class="card-header">
                <h2 class="card-title">NIL Valuation Calculator</h2>
                <div class="card-icon">
                    <i class="fas fa-dollar-sign"></i>
                </div>
            </div>

            <div style="background: linear-gradient(135deg, var(--glass-accent), var(--glass-secondary)); padding: 1.5rem; border-radius: 16px; margin-top: 1rem;">
                <form id="nilCalculatorForm" style="display: grid; gap: 1rem;">
                    <div>
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: var(--championship-gold);">Sport</label>
                        <select id="nilSport" style="width: 100%; padding: 0.75rem; background: var(--glass-primary); border: 1px solid var(--glass-border); border-radius: 8px; color: var(--stadium-lights);">
                            <option value="football">Football</option>
                            <option value="basketball">Basketball</option>
                            <option value="baseball">Baseball</option>
                            <option value="track">Track & Field</option>
                        </select>
                    </div>

                    <div>
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: var(--championship-gold);">Social Media Followers</label>
                        <input type="number" id="nilFollowers" value="50000" placeholder="Total followers" style="width: 100%; padding: 0.75rem; background: var(--glass-primary); border: 1px solid var(--glass-border); border-radius: 8px; color: var(--stadium-lights);">
                    </div>

                    <div>
                        <label style="display: block; font-weight: 600; margin-bottom: 0.5rem; color: var(--championship-gold);">Performance Rating (1-10)</label>
                        <input type="range" id="nilPerformance" min="1" max="10" value="8" style="width: 100%; margin-bottom: 0.5rem;">
                        <div style="text-align: center; font-family: 'JetBrains Mono', monospace; color: var(--burnt-orange);" id="performanceDisplay">8/10</div>
                    </div>

                    <button type="button" id="calculateNilBtn" style="padding: 1rem; background: linear-gradient(135deg, var(--burnt-orange), var(--sec-crimson)); color: white; border: none; border-radius: 8px; font-weight: 700; text-transform: uppercase; cursor: pointer; transition: all 0.3s ease;">
                        Calculate NIL Value
                    </button>
                </form>

                <div id="nilResult" style="margin-top: 1.5rem; padding: 1.5rem; background: var(--glass-primary); border: 1px solid var(--championship-gold); border-radius: 12px; text-align: center; opacity: 0; transition: opacity 0.3s ease;">
                    <div style="font-family: 'Oswald', sans-serif; font-size: 2.5rem; font-weight: 700; color: var(--championship-gold); margin-bottom: 0.5rem;" id="nilValue">$0</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Estimated Annual NIL Value</div>
                    <div style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.5rem;">*Algorithmic estimate - Not financial advice</div>
                </div>
            </div>
        </div>

        <!-- Texas HS Football Recruiting -->
        <div class="dashboard-card">
            <div class="card-header">
                <h2 class="card-title">Texas HS Football Elite</h2>
                <div class="card-icon">
                    <i class="fas fa-star"></i>
                </div>
            </div>

            <div style="margin-top: 1rem;">
                <div style="background: var(--glass-accent); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; border-left: 4px solid var(--burnt-orange);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <span>🏆 Jonah Williams</span>
                        <span style="color: var(--championship-gold);">⭐⭐⭐⭐⭐</span>
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Southlake Carroll • 6A-DI • QB</div>
                    <div style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.25rem;">Committed: Texas Longhorns</div>
                </div>

                <div style="background: var(--glass-accent); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; border-left: 4px solid var(--sec-crimson);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <span>🏈 Marcus Johnson</span>
                        <span style="color: var(--championship-gold);">⭐⭐⭐⭐⭐</span>
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">DeSoto • 6A-DII • RB</div>
                    <div style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.25rem;">Visiting: Alabama, LSU</div>
                </div>

                <div style="background: var(--glass-accent); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; border-left: 4px solid var(--championship-gold);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem; display: flex; justify-content: space-between; align-items: center;">
                        <span>⚡ Dylan Rodriguez</span>
                        <span style="color: var(--championship-gold);">⭐⭐⭐⭐</span>
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Katy • 6A-DI • WR</div>
                    <div style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.25rem;">Top Target: Georgia, Tennessee</div>
                </div>

                <div style="text-align: center; margin-top: 1rem;">
                    <button style="padding: 0.75rem 1.5rem; background: var(--glass-primary); border: 1px solid var(--glass-border-strong); border-radius: 8px; color: var(--stadium-lights); cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.background='var(--burnt-orange)'" onmouseout="this.style.background='var(--glass-primary)'">
                        View Full Rankings
                    </button>
                </div>
            </div>
        </div>

        <!-- Analytics Insights Card -->
        <div class="dashboard-card">
            <div class="card-header">
                <h2 class="card-title">AI-Powered Insights</h2>
                <div class="card-icon">
                    <i class="fas fa-brain"></i>
                </div>
            </div>
            <div style="margin-top: 1rem;">
                <div style="background: var(--glass-accent); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; border-left: 4px solid var(--burnt-orange);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">🎯 Deep South Focus</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Specialized analytics for Texas & SEC sports from youth to professional levels.</div>
                </div>
                <div style="background: var(--glass-accent); padding: 1rem; border-radius: 12px; margin-bottom: 1rem; border-left: 4px solid var(--sec-crimson);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">⚡ Real-Time Processing</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Live data streams with sub-100ms response times for championship-grade performance.</div>
                </div>
                <div style="background: var(--glass-accent); padding: 1rem; border-radius: 12px; border-left: 4px solid var(--championship-gold);">
                    <div style="font-weight: 600; margin-bottom: 0.5rem;">🏆 Premium Experience</div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">Broadcast-quality graphics with cinema-grade 3D visualization technology.</div>
                </div>
            </div>
        </div>

        <!-- 🎲 MONTE CARLO PREDICTIONS ENGINE -->
        <div class="dashboard-card" style="grid-column: span 2;">
            <div class="card-header">
                <h2 class="card-title">🎲 Monte Carlo Championship Predictions</h2>
                <div class="card-icon">
                    <i class="fas fa-dice"></i>
                </div>
            </div>
            <div id="monteCarloDashboard" style="padding: 1.5rem;">
                <!-- Simulation Controls -->
                <div class="monte-carlo-controls" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; margin-bottom: 2rem;">
                    <div class="control-group">
                        <label style="font-size: 0.85rem; opacity: 0.8; display: block; margin-bottom: 0.5rem;">Simulations</label>
                        <select id="mcSimulations" class="monte-control" style="width: 100%; padding: 0.5rem; background: var(--glass-accent); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white;">
                            <option value="1000">1,000 (Fast)</option>
                            <option value="10000" selected>10,000 (Standard)</option>
                            <option value="50000">50,000 (Detailed)</option>
                            <option value="100000">100,000 (Ultra HD)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label style="font-size: 0.85rem; opacity: 0.8; display: block; margin-bottom: 0.5rem;">Team Focus</label>
                        <select id="mcTeam" class="monte-control" style="width: 100%; padding: 0.5rem; background: var(--glass-accent); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white;">
                            <option value="cardinals">St. Louis Cardinals</option>
                            <option value="titans">Tennessee Titans</option>
                            <option value="longhorns">Texas Longhorns</option>
                            <option value="grizzlies">Memphis Grizzlies</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label style="font-size: 0.85rem; opacity: 0.8; display: block; margin-bottom: 0.5rem;">Analysis Type</label>
                        <select id="mcType" class="monte-control" style="width: 100%; padding: 0.5rem; background: var(--glass-accent); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; color: white;">
                            <option value="game">Single Game</option>
                            <option value="season" selected>Season Trajectory</option>
                            <option value="playoffs">Playoff Path</option>
                            <option value="championship">Championship Probability</option>
                        </select>
                    </div>
                    <button id="runMonteCarlo" class="monte-run-btn" style="padding: 0.5rem 1.5rem; background: linear-gradient(135deg, var(--burnt-orange), var(--sec-crimson)); border: none; border-radius: 8px; color: white; font-weight: 600; cursor: pointer; transition: all 0.3s;">
                        <i class="fas fa-play" style="margin-right: 0.5rem;"></i>Run Simulation
                    </button>
                </div>

                <!-- Results Display Grid -->
                <div class="monte-carlo-results" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem;">
                    <!-- Win Probability Card -->
                    <div class="mc-result-card" style="background: var(--glass-accent); padding: 1.5rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--championship-gold);">
                            <i class="fas fa-trophy" style="margin-right: 0.5rem;"></i>Win Probability
                        </h3>
                        <div id="mcWinProbability" style="font-size: 3rem; font-weight: 700; color: var(--burnt-orange); margin: 1rem 0;">
                            --.--%
                        </div>
                        <div style="background: rgba(0,0,0,0.2); height: 8px; border-radius: 4px; overflow: hidden;">
                            <div id="mcWinBar" style="width: 0%; height: 100%; background: linear-gradient(90deg, var(--burnt-orange), var(--championship-gold)); transition: width 1s ease-out;"></div>
                        </div>
                        <div style="display: flex; justify-content: space-between; margin-top: 0.5rem; font-size: 0.85rem; opacity: 0.7;">
                            <span>95% CI:</span>
                            <span id="mcWinCI">-- to --%</span>
                        </div>
                    </div>

                    <!-- Expected Outcomes Card -->
                    <div class="mc-result-card" style="background: var(--glass-accent); padding: 1.5rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--championship-gold);">
                            <i class="fas fa-chart-line" style="margin-right: 0.5rem;"></i>Expected Outcomes
                        </h3>
                        <div style="display: grid; gap: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="opacity: 0.8;">Projected Wins:</span>
                                <span id="mcProjectedWins" style="font-size: 1.5rem; font-weight: 600; color: var(--cardinal-clarity);">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="opacity: 0.8;">Best Case (95%):</span>
                                <span id="mcBestCase" style="font-size: 1.2rem; color: #00FF88;">--</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="opacity: 0.8;">Worst Case (5%):</span>
                                <span id="mcWorstCase" style="font-size: 1.2rem; color: #FF4488;">--</span>
                            </div>
                        </div>
                    </div>

                    <!-- Championship Path Card -->
                    <div class="mc-result-card" style="background: var(--glass-accent); padding: 1.5rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--championship-gold);">
                            <i class="fas fa-route" style="margin-right: 0.5rem;"></i>Championship Path
                        </h3>
                        <div style="display: grid; gap: 0.8rem;">
                            <div class="path-stage" style="display: flex; justify-content: space-between; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <span>Make Playoffs:</span>
                                <span id="mcPlayoffProb" style="font-weight: 600;">--%</span>
                            </div>
                            <div class="path-stage" style="display: flex; justify-content: space-between; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <span>Win Division:</span>
                                <span id="mcDivisionProb" style="font-weight: 600;">--%</span>
                            </div>
                            <div class="path-stage" style="display: flex; justify-content: space-between; padding: 0.5rem; background: rgba(0,0,0,0.2); border-radius: 6px;">
                                <span>Reach Finals:</span>
                                <span id="mcFinalsProb" style="font-weight: 600;">--%</span>
                            </div>
                            <div class="path-stage" style="display: flex; justify-content: space-between; padding: 0.5rem; background: linear-gradient(135deg, rgba(191,87,0,0.2), rgba(155,203,235,0.2)); border-radius: 6px; border: 1px solid var(--championship-gold);">
                                <span style="color: var(--championship-gold);">Win Championship:</span>
                                <span id="mcChampionshipProb" style="font-weight: 700; color: var(--championship-gold);">--%</span>
                            </div>
                        </div>
                    </div>

                    <!-- Probability Distribution Visualization -->
                    <div class="mc-result-card" style="background: var(--glass-accent); padding: 1.5rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); grid-column: span 2;">
                        <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--championship-gold);">
                            <i class="fas fa-chart-area" style="margin-right: 0.5rem;"></i>Probability Distribution
                        </h3>
                        <canvas id="mcDistributionChart" style="width: 100%; height: 250px;"></canvas>
                    </div>

                    <!-- ROI Projections -->
                    <div class="mc-result-card" style="background: var(--glass-accent); padding: 1.5rem; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1);">
                        <h3 style="font-size: 1.1rem; margin-bottom: 1rem; color: var(--championship-gold);">
                            <i class="fas fa-dollar-sign" style="margin-right: 0.5rem;"></i>ROI Projections
                        </h3>
                        <div style="display: grid; gap: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="opacity: 0.8;">Expected Return:</span>
                                <span id="mcExpectedROI" style="font-size: 1.5rem; font-weight: 600; color: #00FF88;">--x</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="opacity: 0.8;">Monthly Value:</span>
                                <span id="mcMonthlyValue" style="font-size: 1.2rem;">$----</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <span style="opacity: 0.8;">Break-Even Conf:</span>
                                <span id="mcBreakEven" style="font-size: 1.2rem;">--%</span>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- 3D Probability Cloud Container -->
                <div id="mcProbabilityCloud" style="margin-top: 2rem; height: 400px; background: var(--glass-accent); border-radius: 12px; position: relative; overflow: hidden;">
                    <div style="position: absolute; top: 1rem; left: 1rem; z-index: 10;">
                        <h3 style="font-size: 1.1rem; color: var(--championship-gold);">
                            <i class="fas fa-cube" style="margin-right: 0.5rem;"></i>3D Probability Space
                        </h3>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- Monte Carlo Engine Scripts -->
    <script src="monte-carlo-engine.js"></script>
    <script src="monte-carlo-visualizer.js"></script>
    <script>
        // Initialize Monte Carlo Dashboard
        document.addEventListener('DOMContentLoaded', function() {
            const runButton = document.getElementById('runMonteCarlo');

            if (runButton && typeof monteCarloEngine !== 'undefined') {
                runButton.addEventListener('click', async function() {
                    const team = document.getElementById('mcTeam').value;
                    const numSims = parseInt(document.getElementById('mcSimulations').value);
                    const analysisType = document.getElementById('mcType').value;

                    // Animate button
                    runButton.innerHTML = '<i class="fas fa-spinner fa-spin" style="margin-right: 0.5rem;"></i>Simulating...';
                    runButton.disabled = true;

                    try {
                        let results;

                        // Run appropriate simulation based on type
                        switch(analysisType) {
                            case 'game':
                                results = await monteCarloEngine.simulateGameOutcome(team, 'opponent', { numSims });
                                break;
                            case 'season':
                                results = await monteCarloEngine.simulateSeasonTrajectory(team, 30, { numSims });
                                break;
                            case 'playoffs':
                            case 'championship':
                                results = await monteCarloEngine.simulateChampionshipPath(team, { numSims });
                                break;
                        }

                        // Update UI with results
                        updateMonteCarloDisplay(results, analysisType);

                        // Also run ROI simulation
                        const roiResults = await monteCarloEngine.simulateFinancialROI({ numSims: 5000 });
                        updateROIDisplay(roiResults);

                    } catch (error) {
                        console.error('Monte Carlo simulation error:', error);
                    } finally {
                        // Reset button
                        runButton.innerHTML = '<i class="fas fa-play" style="margin-right: 0.5rem;"></i>Run Simulation';
                        runButton.disabled = false;
                    }
                });

                // Auto-run initial simulation
                setTimeout(() => {
                    runButton.click();
                }, 2000);
            }
        });

        function updateMonteCarloDisplay(results, type) {
            if (!results) return;

            // Update win probability
            if (results.homeWinProbability !== undefined) {
                const winProb = (results.homeWinProbability * 100).toFixed(1);
                document.getElementById('mcWinProbability').textContent = `${winProb}%`;
                document.getElementById('mcWinBar').style.width = `${winProb}%`;

                const ciLower = ((results.homeWinProbability - 0.05) * 100).toFixed(1);
                const ciUpper = ((results.homeWinProbability + 0.05) * 100).toFixed(1);
                document.getElementById('mcWinCI').textContent = `${ciLower}% to ${ciUpper}%`;
            }

            // Update expected outcomes
            if (results.expectedWins !== undefined) {
                document.getElementById('mcProjectedWins').textContent = Math.round(results.expectedWins);
                document.getElementById('mcBestCase').textContent = results.bestCase || '--';
                document.getElementById('mcWorstCase').textContent = results.worstCase || '--';
            }

            // Update championship path
            if (results.playoffProbability !== undefined) {
                document.getElementById('mcPlayoffProb').textContent = `${(results.playoffProbability * 100).toFixed(1)}%`;
            }
            if (results.championshipProbability !== undefined) {
                document.getElementById('mcChampionshipProb').textContent = `${(results.championshipProbability * 100).toFixed(1)}%`;
                document.getElementById('mcDivisionProb').textContent = `${(results.championshipProbability * 2.5 * 100).toFixed(1)}%`;
                document.getElementById('mcFinalsProb').textContent = `${(results.championshipProbability * 1.5 * 100).toFixed(1)}%`;
            }

            // Animate results
            gsap.from('.mc-result-card', {
                duration: 0.8,
                y: 20,
                opacity: 0,
                stagger: 0.1,
                ease: 'power2.out'
            });
        }

        function updateROIDisplay(results) {
            if (!results || !results.summary) return;

            document.getElementById('mcExpectedROI').textContent = `${results.summary.expectedROI}`;
            document.getElementById('mcMonthlyValue').textContent = results.summary.expectedAnnualValue;
            document.getElementById('mcBreakEven').textContent = results.summary.breakEvenConfidence;
        }
    </script>

    <script>
        // ===== PREMIUM LOADING SEQUENCE =====
        window.addEventListener('load', () => {
            setTimeout(() => {
                document.getElementById('premiumLoader').classList.add('hidden');
                initializePremiumExperience();
            }, 2000);
        });

        // ===== PARTICLE SYSTEM =====
        function initializeParticleSystem() {
            const canvas = document.getElementById('particleCanvas');
            const ctx = canvas.getContext('2d');

            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = [];
            const particleCount = 50;

            class Particle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 0.5;
                    this.vy = (Math.random() - 0.5) * 0.5;
                    this.size = Math.random() * 2 + 1;
                    this.opacity = Math.random() * 0.5 + 0.2;
                    this.color = `rgba(191, 87, 0, ${this.opacity})`;
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = this.color;
                    ctx.fill();
                }
            }

            for (let i = 0; i < particleCount; i++) {
                particles.push(new Particle());
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                particles.forEach(particle => {
                    particle.update();
                    particle.draw();
                });

                requestAnimationFrame(animate);
            }

            animate();

            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }

        // ===== REVOLUTIONARY CHAMPIONSHIP STADIUM ENGINE =====
        class ChampionshipStadiumEngine {
            constructor() {
                this.canvas = null;
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.controls = null;

                // Performance tracking
                this.stats = {
                    fps: 0,
                    renderTime: 0,
                    vertices: 0,
                    frameCount: 0,
                    lastTime: performance.now()
                };

                // Scene elements
                this.stadium = {
                    field: null,
                    stands: [],
                    lights: [],
                    particles: null,
                    goalposts: []
                };

                // Lighting system
                this.lighting = {
                    ambient: null,
                    directional: null,
                    stadium: [],
                    accent: []
                };

                // Settings
                this.currentSport = 'football';
                this.isLightingEnabled = true;
                this.autoRotate = true;
                this.sportModes = ['football', 'baseball', 'basketball'];

                // 🌩️ ULTRA-ADVANCED DYNAMIC WEATHER SYSTEM
                this.weatherSystem = {
                    currentWeather: 'clear', // 'clear', 'light_rain', 'heavy_rain', 'fog', 'snow', 'storm'
                    intensity: 0.0,
                    transitionSpeed: 0.01,
                    targetIntensity: 0.0,
                    cycleTime: 0,
                    autoCycle: false,
                    weatherDuration: 15000, // 15 seconds per weather type when auto-cycling

                    // Environmental parameters
                    windDirection: new THREE.Vector3(1, 0, 0.5).normalize(),
                    windStrength: 0.3,
                    temperature: 72, // Fahrenheit
                    humidity: 0.5,

                    // Weather particle systems
                    particles: {
                        rain: null,
                        snow: null,
                        fog: null
                    },

                    // Environmental effects
                    effects: {
                        wetness: 0.0,
                        visibility: 1.0,
                        ambientDarkening: 0.0,
                        groundReflection: 0.0,
                        grassSaturation: 1.0
                    },

                    // Available weather types
                    weatherTypes: ['clear', 'light_rain', 'heavy_rain', 'fog', 'snow', 'storm']
                };

                // 🎬 CINEMATIC CAMERA SYSTEM
                this.cinematicCamera = {
                    isActive: false,
                    currentSequence: 0,
                    sequenceTime: 0,
                    transitionDuration: 3000, // 3 seconds per transition
                    sequences: [
                        {
                            name: "Stadium Overview",
                            positions: [
                                { x: 0, y: 120, z: 150 },
                                { x: 80, y: 100, z: 120 },
                                { x: -80, y: 100, z: 120 }
                            ],
                            lookAts: [
                                { x: 0, y: 0, z: 0 },
                                { x: 0, y: 0, z: 0 },
                                { x: 0, y: 0, z: 0 }
                            ]
                        },
                        {
                            name: "Field Flyover",
                            positions: [
                                { x: -100, y: 25, z: -50 },
                                { x: 0, y: 30, z: 0 },
                                { x: 100, y: 25, z: 50 }
                            ],
                            lookAts: [
                                { x: 50, y: 0, z: 25 },
                                { x: 0, y: 0, z: 0 },
                                { x: -50, y: 0, z: -25 }
                            ]
                        },
                        {
                            name: "Goalpost Focus",
                            positions: [
                                { x: -120, y: 40, z: 0 },
                                { x: 0, y: 35, z: -80 },
                                { x: 120, y: 40, z: 0 }
                            ],
                            lookAts: [
                                { x: -85, y: 25, z: 0 },
                                { x: 0, y: 20, z: 0 },
                                { x: 85, y: 25, z: 0 }
                            ]
                        },
                        {
                            name: "Championship Angle",
                            positions: [
                                { x: -60, y: 80, z: -100 },
                                { x: 0, y: 150, z: 0 },
                                { x: 60, y: 80, z: 100 }
                            ],
                            lookAts: [
                                { x: 20, y: 10, z: 30 },
                                { x: 0, y: 0, z: 0 },
                                { x: -20, y: 10, z: -30 }
                            ]
                        }
                    ]
                };

                this.init();
            }

            init() {
                this.canvas = document.getElementById('threeDCanvas');
                if (!this.canvas) {
                    console.error('3D Canvas not found');
                    return;
                }

                this.setupRenderer();
                this.setupScene();
                this.setupCamera();
                this.setupControls();
                this.setupLighting();
                this.createStadium();
                this.initializeWeatherSystem(); // 🌩️ Initialize dynamic weather
                this.createStadiumCrowd(); // 🎭 Initialize animated stadium crowd
                this.createHDREnvironment(); // 🌅 Initialize HDR environmental lighting
                this.setupEventListeners();
                this.startRenderLoop();
                this.startPerformanceMonitoring();

                console.log('🏆 Championship Stadium Engine initialized successfully');
            }

            setupRenderer() {
                this.renderer = new THREE.WebGLRenderer({
                    canvas: this.canvas,
                    antialias: window.devicePixelRatio < 2,
                    alpha: true,
                    powerPreference: "high-performance"
                });

                this.renderer.setSize(this.canvas.clientWidth, this.canvas.clientHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.physicallyCorrectLights = true;
                this.renderer.toneMapping = THREE.ACESFilmicToneMapping;
                this.renderer.toneMappingExposure = 1.2;
                this.renderer.setClearColor(0x000814, 0);

                // 🎬 CHAMPIONSHIP POST-PROCESSING EFFECTS PIPELINE
                this.setupPostProcessing();
            }

            setupPostProcessing() {
                // Initialize Effect Composer for advanced visual effects
                if (typeof THREE.EffectComposer !== 'undefined') {
                    this.composer = new THREE.EffectComposer(this.renderer);

                    // Base render pass
                    const renderPass = new THREE.RenderPass(this.scene, this.camera);
                    this.composer.addPass(renderPass);

                    // 🌟 Unreal Bloom Pass - Championship Glow Effects
                    const bloomPass = new THREE.UnrealBloomPass(
                        new THREE.Vector2(window.innerWidth, window.innerHeight),
                        1.2,    // Bloom strength
                        0.4,    // Bloom radius
                        0.1     // Bloom threshold
                    );
                    bloomPass.enabled = true;
                    this.composer.addPass(bloomPass);
                    this.bloomPass = bloomPass;

                    // 🎨 Advanced Color Correction
                    if (typeof THREE.ShaderPass !== 'undefined' && THREE.ColorCorrectionShader) {
                        const colorCorrectionPass = new THREE.ShaderPass(THREE.ColorCorrectionShader);
                        colorCorrectionPass.uniforms.powRGB.value = new THREE.Vector3(1.2, 1.1, 1.0);
                        colorCorrectionPass.uniforms.mulRGB.value = new THREE.Vector3(1.1, 1.0, 0.9);
                        this.composer.addPass(colorCorrectionPass);
                    }

                    // 🔍 Chromatic Aberration for Premium Lens Effect
                    const chromaticAberrationShader = {
                        uniforms: {
                            'tDiffuse': { value: null },
                            'amount': { value: 0.0015 },
                            'angle': { value: 0.0 }
                        },
                        vertexShader: `
                            varying vec2 vUv;
                            void main() {
                                vUv = uv;
                                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                            }
                        `,
                        fragmentShader: `
                            uniform sampler2D tDiffuse;
                            uniform float amount;
                            uniform float angle;
                            varying vec2 vUv;

                            void main() {
                                vec2 offset = amount * vec2(cos(angle), sin(angle));
                                vec4 cr = texture2D(tDiffuse, vUv + offset);
                                vec4 cga = texture2D(tDiffuse, vUv);
                                vec4 cb = texture2D(tDiffuse, vUv - offset);
                                gl_FragColor = vec4(cr.r, cga.g, cb.b, cga.a);
                            }
                        `
                    };

                    if (typeof THREE.ShaderPass !== 'undefined') {
                        const chromaticPass = new THREE.ShaderPass(chromaticAberrationShader);
                        chromaticPass.renderToScreen = true;
                        this.composer.addPass(chromaticPass);
                        this.chromaticPass = chromaticPass;
                    }

                    // Performance optimization
                    this.postProcessingEnabled = window.devicePixelRatio <= 2;
                    console.log('🎬 Championship post-processing pipeline initialized');
                } else {
                    console.warn('Post-processing libraries not available');
                    this.postProcessingEnabled = false;
                }
            }

            setupScene() {
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000814, 50, 300);
            }

            setupCamera() {
                this.camera = new THREE.PerspectiveCamera(
                    65,
                    this.canvas.clientWidth / this.canvas.clientHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 60, 100);
                this.camera.lookAt(0, 0, 0);
            }

            setupControls() {
                if (typeof THREE.OrbitControls !== 'undefined') {
                    this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                    this.controls.enableDamping = true;
                    this.controls.dampingFactor = 0.05;
                    this.controls.minDistance = 30;
                    this.controls.maxDistance = 300;
                    this.controls.maxPolarAngle = Math.PI / 2.2;
                    this.controls.autoRotate = this.autoRotate;
                    this.controls.autoRotateSpeed = 0.5;
                    this.controls.enablePan = true;
                }
            }

            setupLighting() {
                // Ambient lighting
                this.lighting.ambient = new THREE.AmbientLight(0x1a2332, 0.3);
                this.scene.add(this.lighting.ambient);

                // Main directional light (sun)
                this.lighting.directional = new THREE.DirectionalLight(0xffffff, 1.5);
                this.lighting.directional.position.set(100, 150, 50);
                this.lighting.directional.castShadow = true;
                this.lighting.directional.shadow.mapSize.width = 4096;
                this.lighting.directional.shadow.mapSize.height = 4096;
                this.lighting.directional.shadow.camera.near = 0.1;
                this.lighting.directional.shadow.camera.far = 400;
                this.lighting.directional.shadow.camera.left = -150;
                this.lighting.directional.shadow.camera.right = 150;
                this.lighting.directional.shadow.camera.top = 150;
                this.lighting.directional.shadow.camera.bottom = -150;
                this.lighting.directional.shadow.bias = -0.0001;
                this.scene.add(this.lighting.directional);

                // Stadium flood lights
                const floodlightPositions = [
                    [-80, 80, -40], [80, 80, -40], [-80, 80, 40], [80, 80, 40],
                    [0, 90, -60], [0, 90, 60], [-60, 70, 0], [60, 70, 0]
                ];

                floodlightPositions.forEach((pos, index) => {
                    const light = new THREE.SpotLight(0xffaa44, 1.2, 200, Math.PI / 6, 0.5);
                    light.position.set(...pos);
                    light.target.position.set(0, 0, 0);
                    light.castShadow = true;
                    light.shadow.mapSize.width = 2048;
                    light.shadow.mapSize.height = 2048;

                    this.lighting.stadium.push(light);
                    this.scene.add(light);
                    this.scene.add(light.target);

                    // Visual light fixture
                    const lightGeometry = new THREE.ConeGeometry(2, 4, 8);
                    const lightMaterial = new THREE.MeshBasicMaterial({
                        color: 0xffaa44,
                        transparent: true,
                        opacity: 0.8
                    });
                    const lightMesh = new THREE.Mesh(lightGeometry, lightMaterial);
                    lightMesh.position.copy(light.position);
                    lightMesh.lookAt(light.target.position);
                    this.scene.add(lightMesh);
                });

                // Championship accent lights
                const accentColors = [0xBF5700, 0xFFD700, 0x9E1B32, 0x00A3E0];
                accentColors.forEach((color, index) => {
                    const light = new THREE.PointLight(color, 0.4, 100);
                    const angle = (index / accentColors.length) * Math.PI * 2;
                    light.position.set(
                        Math.cos(angle) * 90,
                        25,
                        Math.sin(angle) * 90
                    );
                    this.lighting.accent.push(light);
                    this.scene.add(light);
                });
            }

            createStadium() {
                this.createField();
                this.createStands();
                this.createGoalposts();
                this.createParticleSystem();
                this.addInteractiveElements();
            }

            createField() {
                // 🌱 CHAMPIONSHIP GRASS SHADER SYSTEM
                const fieldGeometry = new THREE.BoxGeometry(160, 2, 100);

                // Advanced grass shader material
                const advancedFieldMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0.0 },
                        uGrassColor1: { value: new THREE.Color(0x2d5016) },
                        uGrassColor2: { value: new THREE.Color(0x1a3009) },
                        uGrassColor3: { value: new THREE.Color(0x3d6b1f) },
                        uPatternScale: { value: 8.0 },
                        uWindStrength: { value: 0.3 },
                        uMoisture: { value: 0.4 },
                        uWearPattern: { value: 0.2 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        uniform float uTime;
                        uniform float uWindStrength;

                        void main() {
                            vUv = uv;
                            vNormal = normal;
                            vPosition = position;

                            // Subtle grass wind animation
                            vec3 pos = position;
                            float windEffect = sin(uTime * 2.0 + position.x * 0.1 + position.z * 0.1) * uWindStrength * 0.1;
                            pos.y += windEffect;

                            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float uTime;
                        uniform vec3 uGrassColor1;
                        uniform vec3 uGrassColor2;
                        uniform vec3 uGrassColor3;
                        uniform float uPatternScale;
                        uniform float uMoisture;
                        uniform float uWearPattern;

                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vPosition;

                        // Procedural noise function
                        float random(vec2 st) {
                            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                        }

                        float noise(vec2 st) {
                            vec2 i = floor(st);
                            vec2 f = fract(st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                        }

                        void main() {
                            vec2 scaledUv = vUv * uPatternScale;

                            // Generate grass blade patterns
                            float grassPattern = noise(scaledUv * 4.0);
                            float grassDetail = noise(scaledUv * 12.0) * 0.5;
                            float grassFine = noise(scaledUv * 24.0) * 0.25;

                            // Combine noise layers for realistic grass texture
                            float grassMask = grassPattern + grassDetail + grassFine;

                            // Wear patterns (more worn in center field)
                            float centerDistance = length(vUv - vec2(0.5, 0.5));
                            float wearEffect = smoothstep(0.0, 0.4, 1.0 - centerDistance) * uWearPattern;

                            // Moisture/wetness effect
                            float moisturePattern = noise(scaledUv * 6.0 + uTime * 0.1) * uMoisture;

                            // Color blending based on patterns
                            vec3 grassColor = mix(
                                mix(uGrassColor1, uGrassColor2, grassMask),
                                uGrassColor3,
                                wearEffect
                            );

                            // Add moisture highlights
                            grassColor = mix(grassColor, grassColor * 1.2, moisturePattern * 0.3);

                            // Simulate subsurface scattering for grass
                            float ndotl = max(0.0, dot(vNormal, normalize(vec3(1.0, 1.0, 1.0))));
                            grassColor *= 0.4 + ndotl * 0.6;

                            gl_FragColor = vec4(grassColor, 1.0);
                        }
                    `,
                    side: THREE.DoubleSide
                });

                // Store reference for animation
                this.advancedFieldMaterial = advancedFieldMaterial;

                this.stadium.field = new THREE.Mesh(fieldGeometry, advancedFieldMaterial);
                this.stadium.field.receiveShadow = true;
                this.stadium.field.castShadow = true;
                this.stadium.field.position.y = -1;
                this.scene.add(this.stadium.field);

                // Field markings with enhanced materials
                this.createFieldMarkings();

                console.log('🌱 Advanced grass shader system initialized');
            }

            createFieldMarkings() {
                const markingMaterial = new THREE.LineBasicMaterial({
                    color: 0xffffff,
                    opacity: 0.9,
                    transparent: true,
                    linewidth: 2
                });

                if (this.currentSport === 'football') {
                    // Yard lines
                    for (let i = -70; i <= 70; i += 10) {
                        const points = [
                            new THREE.Vector3(i, 0.1, -45),
                            new THREE.Vector3(i, 0.1, 45)
                        ];
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(lineGeometry, markingMaterial);
                        this.scene.add(line);
                    }

                    // Sidelines
                    const sidelinePoints = [
                        [new THREE.Vector3(-80, 0.1, -45), new THREE.Vector3(80, 0.1, -45)],
                        [new THREE.Vector3(-80, 0.1, 45), new THREE.Vector3(80, 0.1, 45)]
                    ];

                    sidelinePoints.forEach(points => {
                        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
                        const line = new THREE.Line(lineGeometry, markingMaterial);
                        this.scene.add(line);
                    });

                    // End zones
                    this.createEndZones();
                }
            }

            createEndZones() {
                const endZoneMaterial = new THREE.MeshStandardMaterial({
                    color: 0xBF5700,
                    transparent: true,
                    opacity: 0.3,
                    roughness: 0.9
                });

                const endZoneGeometry = new THREE.BoxGeometry(20, 0.2, 90);

                const endZone1 = new THREE.Mesh(endZoneGeometry, endZoneMaterial);
                endZone1.position.set(-70, 0.1, 0);
                this.scene.add(endZone1);

                const endZone2 = new THREE.Mesh(endZoneGeometry, endZoneMaterial);
                endZone2.position.set(70, 0.1, 0);
                this.scene.add(endZone2);
            }

            createStands() {
                const standMaterial = new THREE.MeshStandardMaterial({
                    color: 0x444444,
                    roughness: 0.7,
                    metalness: 0.3
                });

                // Stadium bowl structure
                const standConfigs = [
                    { x: 0, z: -70, width: 180, height: 40, depth: 20, rotation: 0 },
                    { x: 0, z: 70, width: 180, height: 40, depth: 20, rotation: 0 },
                    { x: -100, z: 0, width: 20, height: 35, depth: 120, rotation: 0 },
                    { x: 100, z: 0, width: 20, height: 35, depth: 120, rotation: 0 }
                ];

                standConfigs.forEach(config => {
                    const geometry = new THREE.BoxGeometry(config.width, config.height, config.depth);
                    const stand = new THREE.Mesh(geometry, standMaterial);
                    stand.position.set(config.x, config.height / 2 + 5, config.z);
                    stand.castShadow = true;
                    stand.receiveShadow = true;
                    this.stadium.stands.push(stand);
                    this.scene.add(stand);
                });
            }

            createGoalposts() {
                if (this.currentSport !== 'football') return;

                // 🏆 CHAMPIONSHIP METALLIC SHADER SYSTEM
                const advancedGoalpostMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        uTime: { value: 0.0 },
                        uGoldColor: { value: new THREE.Color(0xFFD700) },
                        uRustColor: { value: new THREE.Color(0x8B4513) },
                        uDarkMetal: { value: new THREE.Color(0x2F2F2F) },
                        uRustAmount: { value: 0.1 },
                        uWearAmount: { value: 0.15 },
                        uMetalRoughness: { value: 0.2 },
                        uPatternScale: { value: 12.0 }
                    },
                    vertexShader: `
                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec3 vViewPosition;

                        void main() {
                            vUv = uv;
                            vNormal = normalize(normalMatrix * normal);
                            vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                            vPosition = mvPosition.xyz;
                            vViewPosition = -mvPosition.xyz;
                            gl_Position = projectionMatrix * mvPosition;
                        }
                    `,
                    fragmentShader: `
                        uniform float uTime;
                        uniform vec3 uGoldColor;
                        uniform vec3 uRustColor;
                        uniform vec3 uDarkMetal;
                        uniform float uRustAmount;
                        uniform float uWearAmount;
                        uniform float uMetalRoughness;
                        uniform float uPatternScale;

                        varying vec2 vUv;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        varying vec3 vViewPosition;

                        // Advanced noise functions for realistic metal surface
                        float random(vec2 st) {
                            return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
                        }

                        float noise(vec2 st) {
                            vec2 i = floor(st);
                            vec2 f = fract(st);
                            float a = random(i);
                            float b = random(i + vec2(1.0, 0.0));
                            float c = random(i + vec2(0.0, 1.0));
                            float d = random(i + vec2(1.0, 1.0));
                            vec2 u = f * f * (3.0 - 2.0 * f);
                            return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
                        }

                        float fbm(vec2 st) {
                            float value = 0.0;
                            float amplitude = 0.5;
                            float frequency = 1.0;
                            for (int i = 0; i < 4; i++) {
                                value += amplitude * noise(st * frequency);
                                frequency *= 2.0;
                                amplitude *= 0.5;
                            }
                            return value;
                        }

                        void main() {
                            vec2 scaledUv = vUv * uPatternScale;

                            // Generate surface imperfections
                            float surfaceNoise = fbm(scaledUv * 2.0);
                            float rustPattern = fbm(scaledUv + vec2(100.0, 0.0)) * 0.7;
                            float wearPattern = fbm(scaledUv * 0.8 + vec2(0.0, 200.0));

                            // Height-based wear (bottom more weathered)
                            float heightFactor = 1.0 - smoothstep(-1.0, 1.0, vPosition.y * 0.08);
                            float rustMask = step(1.0 - uRustAmount - heightFactor * 0.3, rustPattern);
                            float wearMask = step(1.0 - uWearAmount - heightFactor * 0.2, wearPattern);

                            // Base metallic color
                            vec3 baseColor = uGoldColor;

                            // Apply rust
                            baseColor = mix(baseColor, uRustColor, rustMask * 0.8);

                            // Apply wear and scratches
                            baseColor = mix(baseColor, uDarkMetal, wearMask * 0.6);

                            // Surface variation for realistic metal
                            baseColor += (surfaceNoise - 0.5) * 0.1;

                            // Simple lighting calculation
                            vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
                            float ndotl = max(0.0, dot(vNormal, lightDirection));

                            // Metallic reflection effect
                            vec3 viewDirection = normalize(vViewPosition);
                            vec3 reflectDirection = reflect(-lightDirection, vNormal);
                            float specular = pow(max(0.0, dot(viewDirection, reflectDirection)), 32.0);

                            // Final color with lighting
                            vec3 finalColor = baseColor * (0.3 + ndotl * 0.7) + specular * 0.4;

                            gl_FragColor = vec4(finalColor, 1.0);
                        }
                    `,
                    transparent: false,
                    side: THREE.FrontSide
                });

                // Store reference for animation
                this.advancedGoalpostMaterial = advancedGoalpostMaterial;

                const postPositions = [
                    { x: -85, posts: [{ z: -9 }, { z: 9 }] },
                    { x: 85, posts: [{ z: -9 }, { z: 9 }] }
                ];

                postPositions.forEach(goalpost => {
                    goalpost.posts.forEach(post => {
                        // Vertical posts with advanced metallic shader
                        const postGeometry = new THREE.CylinderGeometry(0.4, 0.4, 25);
                        const postMesh = new THREE.Mesh(postGeometry, advancedGoalpostMaterial);
                        postMesh.position.set(goalpost.x, 12.5, post.z);
                        postMesh.castShadow = true;
                        postMesh.receiveShadow = true;
                        this.scene.add(postMesh);
                    });

                    // Crossbar with realistic weathering
                    const crossbarGeometry = new THREE.CylinderGeometry(0.3, 0.3, 18);
                    const crossbar = new THREE.Mesh(crossbarGeometry, advancedGoalpostMaterial);
                    crossbar.position.set(goalpost.x, 25, 0);
                    crossbar.rotation.z = Math.PI / 2;
                    crossbar.castShadow = true;
                    crossbar.receiveShadow = true;
                    this.scene.add(crossbar);

                    // Championship uprights with premium materials
                    const upright1 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 10),
                        advancedGoalpostMaterial
                    );
                    upright1.position.set(goalpost.x, 30, -9);
                    upright1.castShadow = true;
                    upright1.receiveShadow = true;
                    this.scene.add(upright1);

                    const upright2 = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.3, 0.3, 10),
                        advancedGoalpostMaterial
                    );
                    upright2.position.set(goalpost.x, 30, 9);
                    upright2.castShadow = true;
                    upright2.receiveShadow = true;
                    this.scene.add(upright2);
                });

                console.log('🏆 Advanced metallic goalpost shaders initialized');
            }

            createParticleSystem() {
                // ⚡ CHAMPIONSHIP PHYSICS-BASED PARTICLE SYSTEM
                const particleCount = 1000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(particleCount * 3);
                const colors = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);

                // Enhanced physics properties
                const velocities = new Float32Array(particleCount * 3);
                const accelerations = new Float32Array(particleCount * 3);
                const ages = new Float32Array(particleCount);
                const lifespans = new Float32Array(particleCount);
                const masses = new Float32Array(particleCount);

                const colorPalette = [
                    new THREE.Color(0xBF5700), // Burnt orange
                    new THREE.Color(0xFFD700), // Championship gold
                    new THREE.Color(0x9E1B32), // SEC crimson
                    new THREE.Color(0x00A3E0), // Accent blue
                    new THREE.Color(0x2D5016)  // Field green
                ];

                // Physics constants
                this.particlePhysics = {
                    gravity: new THREE.Vector3(0, -0.002, 0),
                    windForce: new THREE.Vector3(0.001, 0, 0.002),
                    damping: 0.98,
                    collisionRadius: 2.0,
                    fieldBounds: {
                        min: new THREE.Vector3(-100, 1, -70),
                        max: new THREE.Vector3(100, 100, 70)
                    }
                };

                for (let i = 0; i < particleCount; i++) {
                    const i3 = i * 3;

                    // Enhanced stadium-centered distribution with zones
                    const zone = Math.random();
                    if (zone < 0.4) {
                        // Field area particles (dust, grass particles)
                        positions[i3] = (Math.random() - 0.5) * 160;
                        positions[i3 + 1] = Math.random() * 15 + 2;
                        positions[i3 + 2] = (Math.random() - 0.5) * 100;
                        masses[i] = 0.8 + Math.random() * 0.4; // Heavier field particles
                    } else if (zone < 0.8) {
                        // Atmosphere particles (light effects, confetti)
                        positions[i3] = (Math.random() - 0.5) * 200;
                        positions[i3 + 1] = Math.random() * 60 + 20;
                        positions[i3 + 2] = (Math.random() - 0.5) * 140;
                        masses[i] = 0.1 + Math.random() * 0.3; // Lighter atmosphere particles
                    } else {
                        // High atmosphere sparkles
                        positions[i3] = (Math.random() - 0.5) * 250;
                        positions[i3 + 1] = Math.random() * 40 + 60;
                        positions[i3 + 2] = (Math.random() - 0.5) * 180;
                        masses[i] = 0.05 + Math.random() * 0.15; // Very light sparkle particles
                    }

                    // Physics-based initial velocities
                    velocities[i3] = (Math.random() - 0.5) * 0.2;
                    velocities[i3 + 1] = Math.random() * 0.1 + 0.02;
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.2;

                    // Initialize accelerations to zero
                    accelerations[i3] = 0;
                    accelerations[i3 + 1] = 0;
                    accelerations[i3 + 2] = 0;

                    // Particle lifecycle
                    ages[i] = Math.random() * 100;
                    lifespans[i] = 200 + Math.random() * 300;

                    // Dynamic championship colors based on zone
                    const colorIndex = zone < 0.4 ? 4 : Math.floor(Math.random() * 4); // Field particles are green
                    const color = colorPalette[colorIndex];
                    colors[i3] = color.r;
                    colors[i3 + 1] = color.g;
                    colors[i3 + 2] = color.b;

                    // Size based on mass and zone
                    sizes[i] = masses[i] * 3 + Math.random() * 2;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));

                // Enhanced physics data storage
                geometry.userData = {
                    velocities: velocities,
                    accelerations: accelerations,
                    ages: ages,
                    lifespans: lifespans,
                    masses: masses
                };

                // Premium particle material with enhanced effects
                const material = new THREE.PointsMaterial({
                    size: 2.5,
                    transparent: true,
                    opacity: 0.7,
                    vertexColors: true,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: true,
                    alphaTest: 0.1
                });

                this.stadium.particles = new THREE.Points(geometry, material);
                this.scene.add(this.stadium.particles);

                console.log('⚡ Championship physics-based particle system initialized');
            }

            // ⚡ PARTICLE RESPAWN SYSTEM
            respawnParticle(index, positions, velocities, ages, lifespans, masses, colors, sizes) {
                const i3 = index * 3;

                // Reset particle lifecycle
                ages[index] = 0;
                lifespans[index] = 200 + Math.random() * 300;

                // Respawn in realistic locations
                const spawnZone = Math.random();
                if (spawnZone < 0.3) {
                    // Field edge spawn (dust kicked up)
                    positions[i3] = (Math.random() - 0.5) * 160;
                    positions[i3 + 1] = 1 + Math.random() * 3;
                    positions[i3 + 2] = (Math.random() - 0.5) * 100;
                    masses[index] = 0.8 + Math.random() * 0.4;
                } else if (spawnZone < 0.7) {
                    // Stadium atmosphere
                    positions[i3] = (Math.random() - 0.5) * 220;
                    positions[i3 + 1] = 20 + Math.random() * 30;
                    positions[i3 + 2] = (Math.random() - 0.5) * 150;
                    masses[index] = 0.2 + Math.random() * 0.3;
                } else {
                    // High altitude sparkles
                    positions[i3] = (Math.random() - 0.5) * 280;
                    positions[i3 + 1] = 70 + Math.random() * 20;
                    positions[i3 + 2] = (Math.random() - 0.5) * 200;
                    masses[index] = 0.05 + Math.random() * 0.15;
                }

                // Reset velocity with some randomness
                velocities[i3] = (Math.random() - 0.5) * 0.15;
                velocities[i3 + 1] = Math.random() * 0.05 + 0.01;
                velocities[i3 + 2] = (Math.random() - 0.5) * 0.15;

                // Reassign colors based on spawn zone
                const colorPalette = [
                    { r: 0.75, g: 0.34, b: 0 },    // Burnt orange
                    { r: 1.0, g: 0.84, b: 0 },     // Championship gold
                    { r: 0.62, g: 0.11, b: 0.2 },  // SEC crimson
                    { r: 0, g: 0.64, b: 0.88 },    // Accent blue
                    { r: 0.18, g: 0.31, b: 0.09 }  // Field green
                ];

                const colorIndex = spawnZone < 0.3 ? 4 : Math.floor(Math.random() * 4);
                const color = colorPalette[colorIndex];
                colors[i3] = color.r;
                colors[i3 + 1] = color.g;
                colors[i3 + 2] = color.b;

                // Reset size
                sizes[index] = masses[index] * 3 + Math.random() * 2;
            }

            addInteractiveElements() {
                // Add clickable stadium elements for analytics
                const interactiveGeometry = new THREE.SphereGeometry(5, 16, 16);
                const interactiveMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.1
                });

                const interactiveElements = [
                    { x: 0, y: 10, z: 0, name: "Field Center" },
                    { x: 0, y: 10, z: -40, name: "North End Zone" },
                    { x: 0, y: 10, z: 40, name: "South End Zone" }
                ];

                interactiveElements.forEach(element => {
                    const mesh = new THREE.Mesh(interactiveGeometry, interactiveMaterial.clone());
                    mesh.position.set(element.x, element.y, element.z);
                    mesh.userData = { name: element.name, clickable: true };
                    this.scene.add(mesh);
                });
            }

            changeSport(sport) {
                this.currentSport = sport;

                // Update sport indicator
                const indicator = document.getElementById('sportIndicator');
                const sportEmojis = {
                    'football': '🏈 FOOTBALL MODE',
                    'baseball': '⚾ BASEBALL MODE',
                    'basketball': '🏀 BASKETBALL MODE'
                };
                indicator.textContent = sportEmojis[sport] || '🏈 FOOTBALL MODE';

                // Clear existing field markings
                this.scene.children = this.scene.children.filter(child =>
                    !child.isLine && !child.userData?.isFieldMarking
                );

                this.createFieldMarkings();
                console.log(`🏆 Stadium reconfigured for ${sport}`);
            }

            toggleLighting() {
                this.isLightingEnabled = !this.isLightingEnabled;

                this.lighting.stadium.forEach(light => {
                    light.intensity = this.isLightingEnabled ? 1.2 : 0.2;
                });

                this.lighting.accent.forEach(light => {
                    light.intensity = this.isLightingEnabled ? 0.4 : 0.1;
                });

                console.log(`💡 Stadium lighting ${this.isLightingEnabled ? 'enabled' : 'dimmed'}`);
            }

            resetCamera() {
                if (this.controls) {
                    gsap.to(this.camera.position, {
                        duration: 2,
                        x: 0,
                        y: 60,
                        z: 100,
                        ease: "power2.inOut",
                        onUpdate: () => {
                            this.controls.update();
                        }
                    });
                }
            }

            toggleAutoRotate() {
                this.autoRotate = !this.autoRotate;
                if (this.controls) {
                    this.controls.autoRotate = this.autoRotate;
                }
                console.log(`🔄 Auto-rotate ${this.autoRotate ? 'enabled' : 'disabled'}`);
            }

            enterFullscreen() {
                const container = this.canvas.parentElement;
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                } else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
            }

            setupEventListeners() {
                // Control buttons
                document.getElementById('resetCameraBtn')?.addEventListener('click', () => this.resetCamera());
                document.getElementById('toggleLightingBtn')?.addEventListener('click', () => this.toggleLighting());
                document.getElementById('changeSportBtn')?.addEventListener('click', () => {
                    const currentIndex = this.sportModes.indexOf(this.currentSport);
                    const nextSport = this.sportModes[(currentIndex + 1) % this.sportModes.length];
                    this.changeSport(nextSport);
                });
                document.getElementById('fullscreenBtn')?.addEventListener('click', () => this.enterFullscreen());
                document.getElementById('autoRotateBtn')?.addEventListener('click', () => this.toggleAutoRotate());

                // 🎬 Post-processing controls
                document.getElementById('togglePostProcessingBtn')?.addEventListener('click', () => this.togglePostProcessing());
                document.getElementById('toggleBloomBtn')?.addEventListener('click', () => this.toggleBloom());
                document.getElementById('toggleChromaticBtn')?.addEventListener('click', () => this.toggleChromaticAberration());

                // 🎬 Cinematic camera controls
                document.getElementById('startCinematicBtn')?.addEventListener('click', () => this.startCinematicSequence());

                // 🌩️ Weather system controls
                document.getElementById('weatherClearBtn')?.addEventListener('click', () => this.setWeather('clear'));
                document.getElementById('weatherRainBtn')?.addEventListener('click', () => this.setWeather('heavy_rain'));
                document.getElementById('weatherSnowBtn')?.addEventListener('click', () => this.setWeather('snow'));
                document.getElementById('weatherFogBtn')?.addEventListener('click', () => this.setWeather('fog'));
                document.getElementById('weatherCycleBtn')?.addEventListener('click', () => this.toggleWeatherCycle());

                // Resize handler
                window.addEventListener('resize', () => this.handleResize());

                // Mouse interactions
                this.canvas.addEventListener('click', (event) => this.handleMouseClick(event));
            }

            handleMouseClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const mouse = new THREE.Vector2(
                    ((event.clientX - rect.left) / rect.width) * 2 - 1,
                    -((event.clientY - rect.top) / rect.height) * 2 + 1
                );

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);

                const clickableObjects = this.scene.children.filter(obj => obj.userData?.clickable);
                const intersects = raycaster.intersectObjects(clickableObjects);

                if (intersects.length > 0) {
                    const obj = intersects[0].object;
                    this.showDataOverlay(obj.userData.name);
                }
            }

            showDataOverlay(elementName) {
                const overlay = document.getElementById('dataOverlay');
                overlay.innerHTML = `
                    <div style="font-weight: 700; color: var(--championship-gold); margin-bottom: 8px;">
                        ${elementName}
                    </div>
                    <div style="font-size: 0.9rem; opacity: 0.9;">
                        Analytics data for ${elementName} would appear here
                    </div>
                `;
                overlay.classList.add('active');

                setTimeout(() => {
                    overlay.classList.remove('active');
                }, 3000);
            }

            handleResize() {
                const width = this.canvas.clientWidth;
                const height = this.canvas.clientHeight;

                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(width, height);

                // 🎬 Update post-processing pipeline size
                if (this.composer) {
                    this.composer.setSize(width, height);

                    // Update bloom pass resolution
                    if (this.bloomPass) {
                        this.bloomPass.resolution.set(width, height);
                    }
                }

                console.log('📐 Stadium viewport and post-processing pipeline resized:', width, 'x', height);
            }

            // 🎬 POST-PROCESSING INTERACTIVE CONTROLS
            togglePostProcessing() {
                this.postProcessingEnabled = !this.postProcessingEnabled;
                const btn = document.getElementById('togglePostProcessingBtn');
                if (btn) {
                    btn.style.color = this.postProcessingEnabled ? 'var(--championship-gold)' : 'var(--stadium-lights)';
                }
                console.log('🎬 Post-processing:', this.postProcessingEnabled ? 'ENABLED' : 'DISABLED');
            }

            toggleBloom() {
                if (this.bloomPass) {
                    this.bloomPass.enabled = !this.bloomPass.enabled;
                    const btn = document.getElementById('toggleBloomBtn');
                    if (btn) {
                        btn.style.color = this.bloomPass.enabled ? 'var(--championship-gold)' : 'var(--stadium-lights)';
                    }
                    console.log('🌟 Bloom effect:', this.bloomPass.enabled ? 'ENABLED' : 'DISABLED');
                }
            }

            toggleChromaticAberration() {
                if (this.chromaticPass) {
                    this.chromaticPass.enabled = !this.chromaticPass.enabled;
                    const btn = document.getElementById('toggleChromaticBtn');
                    if (btn) {
                        btn.style.color = this.chromaticPass.enabled ? 'var(--championship-gold)' : 'var(--stadium-lights)';
                    }
                    console.log('🔍 Chromatic aberration:', this.chromaticPass.enabled ? 'ENABLED' : 'DISABLED');
                }
            }

            // 🌩️ ULTRA-ADVANCED DYNAMIC WEATHER SYSTEM METHODS
            initializeWeatherSystem() {
                this.createRainSystem();
                this.createSnowSystem();
                this.createFogSystem();
                console.log('🌩️ Dynamic weather system initialized');
            }

            createRainSystem() {
                const rainCount = 1500;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(rainCount * 3);
                const velocities = new Float32Array(rainCount * 3);
                const sizes = new Float32Array(rainCount);

                for (let i = 0; i < rainCount; i++) {
                    const i3 = i * 3;

                    // Distribute rain across wider area above stadium
                    positions[i3] = (Math.random() - 0.5) * 300;
                    positions[i3 + 1] = Math.random() * 100 + 50;
                    positions[i3 + 2] = (Math.random() - 0.5) * 200;

                    // Rain falls downward with wind effect
                    velocities[i3] = this.weatherSystem.windDirection.x * 2;
                    velocities[i3 + 1] = -8 - Math.random() * 4; // Fast downward
                    velocities[i3 + 2] = this.weatherSystem.windDirection.z * 2;

                    sizes[i] = 0.5 + Math.random() * 0.3;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.userData = { velocities: velocities };

                const rainMaterial = new THREE.PointsMaterial({
                    color: 0x87CEEB,
                    size: 0.8,
                    transparent: true,
                    opacity: 0.6,
                    blending: THREE.AdditiveBlending,
                    sizeAttenuation: false
                });

                this.weatherSystem.particles.rain = new THREE.Points(geometry, rainMaterial);
                this.weatherSystem.particles.rain.visible = false;
                this.scene.add(this.weatherSystem.particles.rain);
            }

            createSnowSystem() {
                const snowCount = 800;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(snowCount * 3);
                const velocities = new Float32Array(snowCount * 3);
                const sizes = new Float32Array(snowCount);

                for (let i = 0; i < snowCount; i++) {
                    const i3 = i * 3;

                    positions[i3] = (Math.random() - 0.5) * 250;
                    positions[i3 + 1] = Math.random() * 100 + 30;
                    positions[i3 + 2] = (Math.random() - 0.5) * 180;

                    // Snow falls slower and drifts more
                    velocities[i3] = (Math.random() - 0.5) * 0.5 + this.weatherSystem.windDirection.x;
                    velocities[i3 + 1] = -1 - Math.random() * 1.5; // Gentle fall
                    velocities[i3 + 2] = (Math.random() - 0.5) * 0.5 + this.weatherSystem.windDirection.z;

                    sizes[i] = 1 + Math.random() * 2;
                }

                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.userData = { velocities: velocities };

                const snowMaterial = new THREE.PointsMaterial({
                    color: 0xFFFFFF,
                    size: 2,
                    transparent: true,
                    opacity: 0.8,
                    blending: THREE.NormalBlending,
                    sizeAttenuation: true
                });

                this.weatherSystem.particles.snow = new THREE.Points(geometry, snowMaterial);
                this.weatherSystem.particles.snow.visible = false;
                this.scene.add(this.weatherSystem.particles.snow);
            }

            createFogSystem() {
                // Create volumetric fog effect using multiple layers
                const fogGeometry = new THREE.PlaneGeometry(400, 400);
                const fogMaterial = new THREE.MeshBasicMaterial({
                    color: 0xCCCCCC,
                    transparent: true,
                    opacity: 0.0,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending
                });

                this.weatherSystem.particles.fog = new THREE.Mesh(fogGeometry, fogMaterial);
                this.weatherSystem.particles.fog.position.set(0, 15, 0);
                this.weatherSystem.particles.fog.rotation.x = -Math.PI / 2;
                this.weatherSystem.particles.fog.visible = false;
                this.scene.add(this.weatherSystem.particles.fog);
            }

            setWeather(weatherType) {
                // Update UI button states
                this.updateWeatherButtonStates(weatherType);

                this.weatherSystem.currentWeather = weatherType;
                this.weatherSystem.targetIntensity = weatherType === 'clear' ? 0.0 : 1.0;

                // Set specific intensities for different weather types
                switch(weatherType) {
                    case 'light_rain':
                        this.weatherSystem.targetIntensity = 0.4;
                        break;
                    case 'heavy_rain':
                        this.weatherSystem.targetIntensity = 1.0;
                        break;
                    case 'snow':
                        this.weatherSystem.targetIntensity = 0.8;
                        break;
                    case 'fog':
                        this.weatherSystem.targetIntensity = 0.6;
                        break;
                    case 'storm':
                        this.weatherSystem.targetIntensity = 1.2;
                        break;
                    default: // clear
                        this.weatherSystem.targetIntensity = 0.0;
                }

                console.log(`🌩️ Weather changed to: ${weatherType} (intensity: ${this.weatherSystem.targetIntensity})`);
            }

            updateWeatherButtonStates(activeWeather) {
                // Reset all weather buttons
                const weatherButtons = ['weatherClearBtn', 'weatherRainBtn', 'weatherSnowBtn', 'weatherFogBtn'];
                weatherButtons.forEach(id => {
                    const btn = document.getElementById(id);
                    if (btn) btn.style.color = 'var(--stadium-lights)';
                });

                // Highlight active weather button
                let activeButtonId = '';
                switch(activeWeather) {
                    case 'clear': activeButtonId = 'weatherClearBtn'; break;
                    case 'heavy_rain':
                    case 'light_rain': activeButtonId = 'weatherRainBtn'; break;
                    case 'snow': activeButtonId = 'weatherSnowBtn'; break;
                    case 'fog': activeButtonId = 'weatherFogBtn'; break;
                }

                if (activeButtonId) {
                    const btn = document.getElementById(activeButtonId);
                    if (btn) btn.style.color = 'var(--championship-gold)';
                }
            }

            toggleWeatherCycle() {
                this.weatherSystem.autoCycle = !this.weatherSystem.autoCycle;
                this.weatherSystem.cycleTime = 0;

                const btn = document.getElementById('weatherCycleBtn');
                if (btn) {
                    btn.style.color = this.weatherSystem.autoCycle ? 'var(--championship-gold)' : 'var(--stadium-lights)';
                }

                console.log('🌩️ Weather auto-cycle:', this.weatherSystem.autoCycle ? 'ENABLED' : 'DISABLED');
            }

            updateWeatherSystem() {
                const time = Date.now() * 0.001;

                // Auto-cycle through weather types
                if (this.weatherSystem.autoCycle) {
                    this.weatherSystem.cycleTime += 16.67; // ~60fps
                    if (this.weatherSystem.cycleTime >= this.weatherSystem.weatherDuration) {
                        const currentIndex = this.weatherSystem.weatherTypes.indexOf(this.weatherSystem.currentWeather);
                        const nextIndex = (currentIndex + 1) % this.weatherSystem.weatherTypes.length;
                        this.setWeather(this.weatherSystem.weatherTypes[nextIndex]);
                        this.weatherSystem.cycleTime = 0;
                    }
                }

                // Smooth intensity transitions
                if (Math.abs(this.weatherSystem.intensity - this.weatherSystem.targetIntensity) > 0.001) {
                    this.weatherSystem.intensity = THREE.MathUtils.lerp(
                        this.weatherSystem.intensity,
                        this.weatherSystem.targetIntensity,
                        this.weatherSystem.transitionSpeed
                    );
                }

                // Update weather particle systems
                this.updateWeatherParticles(time);
                this.updateEnvironmentalEffects(time);
            }

            updateWeatherParticles(time) {
                const weather = this.weatherSystem.currentWeather;
                const intensity = this.weatherSystem.intensity;

                // Hide all weather particles first
                if (this.weatherSystem.particles.rain) this.weatherSystem.particles.rain.visible = false;
                if (this.weatherSystem.particles.snow) this.weatherSystem.particles.snow.visible = false;
                if (this.weatherSystem.particles.fog) this.weatherSystem.particles.fog.visible = false;

                // Show and animate appropriate weather system
                if (intensity > 0.1) {
                    if (weather === 'heavy_rain' || weather === 'light_rain' || weather === 'storm') {
                        this.animateRain(time, intensity);
                    } else if (weather === 'snow') {
                        this.animateSnow(time, intensity);
                    } else if (weather === 'fog') {
                        this.animateFog(time, intensity);
                    }
                }
            }

            animateRain(time, intensity) {
                const rain = this.weatherSystem.particles.rain;
                if (!rain) return;

                rain.visible = true;
                rain.material.opacity = intensity * 0.6;

                const positions = rain.geometry.attributes.position.array;
                const velocities = rain.geometry.userData.velocities;

                for (let i = 0; i < positions.length; i += 3) {
                    positions[i] += velocities[i] * intensity;
                    positions[i + 1] += velocities[i + 1] * intensity;
                    positions[i + 2] += velocities[i + 2] * intensity;

                    // Reset raindrops that hit the ground or go too far
                    if (positions[i + 1] < 1 || Math.abs(positions[i]) > 150 || Math.abs(positions[i + 2]) > 100) {
                        positions[i] = (Math.random() - 0.5) * 300;
                        positions[i + 1] = 100 + Math.random() * 50;
                        positions[i + 2] = (Math.random() - 0.5) * 200;
                    }
                }

                rain.geometry.attributes.position.needsUpdate = true;
            }

            animateSnow(time, intensity) {
                const snow = this.weatherSystem.particles.snow;
                if (!snow) return;

                snow.visible = true;
                snow.material.opacity = intensity * 0.8;

                const positions = snow.geometry.attributes.position.array;
                const velocities = snow.geometry.userData.velocities;

                for (let i = 0; i < positions.length; i += 3) {
                    // Add gentle drift motion
                    const drift = Math.sin(time * 0.5 + positions[i] * 0.01) * 0.1;

                    positions[i] += velocities[i] * intensity + drift;
                    positions[i + 1] += velocities[i + 1] * intensity;
                    positions[i + 2] += velocities[i + 2] * intensity + drift * 0.5;

                    // Reset snowflakes
                    if (positions[i + 1] < 1 || Math.abs(positions[i]) > 125 || Math.abs(positions[i + 2]) > 90) {
                        positions[i] = (Math.random() - 0.5) * 250;
                        positions[i + 1] = 80 + Math.random() * 40;
                        positions[i + 2] = (Math.random() - 0.5) * 180;
                    }
                }

                snow.geometry.attributes.position.needsUpdate = true;
            }

            animateFog(time, intensity) {
                const fog = this.weatherSystem.particles.fog;
                if (!fog) return;

                fog.visible = true;
                fog.material.opacity = intensity * 0.3;

                // Gentle rotation and breathing effect
                fog.rotation.z = time * 0.02;
                fog.scale.setScalar(1 + Math.sin(time * 0.1) * 0.1);
            }

            updateEnvironmentalEffects(time) {
                const weather = this.weatherSystem.currentWeather;
                const intensity = this.weatherSystem.intensity;

                // Update environmental parameters based on weather
                if (weather === 'heavy_rain' || weather === 'light_rain' || weather === 'storm') {
                    this.weatherSystem.effects.wetness = intensity * 0.8;
                    this.weatherSystem.effects.ambientDarkening = intensity * 0.4;
                    this.weatherSystem.effects.visibility = 1.0 - intensity * 0.3;
                } else if (weather === 'snow') {
                    this.weatherSystem.effects.ambientDarkening = intensity * 0.2;
                    this.weatherSystem.effects.visibility = 1.0 - intensity * 0.4;
                } else if (weather === 'fog') {
                    this.weatherSystem.effects.visibility = 1.0 - intensity * 0.7;
                    this.weatherSystem.effects.ambientDarkening = intensity * 0.5;
                } else {
                    this.weatherSystem.effects.wetness = Math.max(0, this.weatherSystem.effects.wetness - 0.01);
                    this.weatherSystem.effects.ambientDarkening = Math.max(0, this.weatherSystem.effects.ambientDarkening - 0.01);
                    this.weatherSystem.effects.visibility = Math.min(1.0, this.weatherSystem.effects.visibility + 0.01);
                }

                // Apply effects to scene lighting
                if (this.lighting.ambient) {
                    const baseBrightness = 0.3;
                    this.lighting.ambient.intensity = baseBrightness * (1.0 - this.weatherSystem.effects.ambientDarkening);
                }

                // Update fog density
                if (this.scene.fog) {
                    const baseFar = 300;
                    this.scene.fog.far = baseFar * this.weatherSystem.effects.visibility;
                }

                // Update field material wetness (if advanced field material exists)
                if (this.advancedFieldMaterial) {
                    this.advancedFieldMaterial.uniforms.uMoisture.value = 0.4 + this.weatherSystem.effects.wetness * 0.4;
                }
            }

            // 🎬 CINEMATIC CAMERA SYSTEM
            startCinematicSequence() {
                if (this.cinematicCamera.isActive) {
                    // Stop current sequence
                    this.cinematicCamera.isActive = false;
                    this.cinematicCamera.currentSequence = 0;
                    this.cinematicCamera.sequenceTime = 0;
                    if (this.controls) {
                        this.controls.enabled = true;
                        this.controls.autoRotate = this.autoRotate;
                    }
                    const btn = document.getElementById('startCinematicBtn');
                    if (btn) {
                        btn.style.color = 'var(--stadium-lights)';
                        btn.innerHTML = '<i class="fas fa-video"></i>';
                    }
                    console.log('🎬 Cinematic sequence stopped');
                } else {
                    // Start cinematic sequence
                    this.cinematicCamera.isActive = true;
                    this.cinematicCamera.currentSequence = 0;
                    this.cinematicCamera.sequenceTime = 0;
                    if (this.controls) {
                        this.controls.enabled = false;
                        this.controls.autoRotate = false;
                    }
                    const btn = document.getElementById('startCinematicBtn');
                    if (btn) {
                        btn.style.color = 'var(--championship-gold)';
                        btn.innerHTML = '<i class="fas fa-stop"></i>';
                    }
                    console.log('🎬 Starting cinematic sequence');
                }
            }

            updateCinematicCamera() {
                if (!this.cinematicCamera.isActive) return;

                const time = Date.now() * 0.001;
                this.cinematicCamera.sequenceTime += 16.67; // ~60fps

                const currentSeq = this.cinematicCamera.sequences[this.cinematicCamera.currentSequence];
                const duration = this.cinematicCamera.transitionDuration;
                const progress = Math.min(this.cinematicCamera.sequenceTime / duration, 1.0);

                // Smooth easing function (ease-in-out)
                const easeInOut = t => t * t * (3.0 - 2.0 * t);
                const easedProgress = easeInOut(progress);

                // Determine current keyframes
                const numKeyframes = currentSeq.positions.length;
                const keyframeIndex = Math.floor(easedProgress * (numKeyframes - 1));
                const nextKeyframeIndex = Math.min(keyframeIndex + 1, numKeyframes - 1);
                const localProgress = (easedProgress * (numKeyframes - 1)) - keyframeIndex;

                // Interpolate camera position
                const pos1 = currentSeq.positions[keyframeIndex];
                const pos2 = currentSeq.positions[nextKeyframeIndex];
                const lookAt1 = currentSeq.lookAts[keyframeIndex];
                const lookAt2 = currentSeq.lookAts[nextKeyframeIndex];

                // Smooth interpolation with cinematic curves
                const cinematicEase = t => {
                    // Custom cinematic easing for smoother camera movement
                    return t * t * t * (t * (t * 6 - 15) + 10);
                };
                const smoothProgress = cinematicEase(localProgress);

                // Calculate interpolated position
                const cameraPos = {
                    x: pos1.x + (pos2.x - pos1.x) * smoothProgress,
                    y: pos1.y + (pos2.y - pos1.y) * smoothProgress,
                    z: pos1.z + (pos2.z - pos1.z) * smoothProgress
                };

                // Calculate interpolated look-at target
                const lookAtTarget = {
                    x: lookAt1.x + (lookAt2.x - lookAt1.x) * smoothProgress,
                    y: lookAt1.y + (lookAt2.y - lookAt1.y) * smoothProgress,
                    z: lookAt1.z + (lookAt2.z - lookAt1.z) * smoothProgress
                };

                // Add subtle camera shake for dynamic feel
                const shake = 0.2;
                cameraPos.x += Math.sin(time * 8.5) * shake;
                cameraPos.y += Math.sin(time * 7.2) * shake * 0.5;
                cameraPos.z += Math.cos(time * 6.8) * shake;

                // Apply camera position and target
                this.camera.position.set(cameraPos.x, cameraPos.y, cameraPos.z);
                this.camera.lookAt(lookAtTarget.x, lookAtTarget.y, lookAtTarget.z);

                // Move to next sequence if current one is complete
                if (progress >= 1.0) {
                    this.cinematicCamera.currentSequence =
                        (this.cinematicCamera.currentSequence + 1) % this.cinematicCamera.sequences.length;
                    this.cinematicCamera.sequenceTime = 0;

                    // Optional: Stop after completing all sequences
                    if (this.cinematicCamera.currentSequence === 0) {
                        console.log('🎬 Cinematic sequence completed, restarting...');
                    }
                }
            }

            startPerformanceMonitoring() {
                let frameCount = 0;
                let lastTime = performance.now();

                setInterval(() => {
                    const now = performance.now();
                    this.stats.fps = Math.round((frameCount * 1000) / (now - lastTime));
                    frameCount = 0;
                    lastTime = now;

                    // Update performance UI
                    document.getElementById('fpsCounter').textContent = `FPS: ${this.stats.fps}`;

                    // Performance warnings
                    if (this.stats.fps < 30) {
                        console.warn('⚠️ Low FPS detected:', this.stats.fps);
                    }
                }, 1000);

                // Frame-based metrics
                const originalRender = this.renderer.render.bind(this.renderer);
                this.renderer.render = (...args) => {
                    const start = performance.now();
                    originalRender(...args);
                    this.stats.renderTime = performance.now() - start;

                    frameCount++;
                    document.getElementById('renderTime').textContent = `Render: ${this.stats.renderTime.toFixed(1)}ms`;
                };
            }

            // 🎭 CHAMPIONSHIP STADIUM CROWD SIMULATION - Ultra-realistic crowd dynamics
            createStadiumCrowd() {
                console.log('🎭 Initializing Championship Crowd Simulation...');

                this.crowdSystem = {
                    active: true,
                    totalFans: 5000,
                    sections: [],
                    waveActive: false,
                    wavePosition: 0,
                    waveSpeed: 50,
                    excitement: 0.5,
                    homeTeamScore: 0,
                    awayTeamScore: 0,
                    animations: {
                        idle: [],
                        cheer: [],
                        wave: [],
                        jump: [],
                        clap: []
                    }
                };

                // Create stadium sections (lower bowl, upper bowl, end zones)
                const sectionConfigs = [
                    { name: 'Lower West', x: -100, y: 10, z: 0, rows: 20, cols: 50, teamAffinity: 'home' },
                    { name: 'Lower East', x: 100, y: 10, z: 0, rows: 20, cols: 50, teamAffinity: 'away' },
                    { name: 'North End Zone', x: 0, y: 15, z: -80, rows: 15, cols: 30, teamAffinity: 'mixed' },
                    { name: 'South End Zone', x: 0, y: 15, z: 80, rows: 15, cols: 30, teamAffinity: 'mixed' },
                    { name: 'Upper West', x: -120, y: 30, z: 0, rows: 15, cols: 40, teamAffinity: 'home' },
                    { name: 'Upper East', x: 120, y: 30, z: 0, rows: 15, cols: 40, teamAffinity: 'away' }
                ];

                // Use instanced mesh for performance
                const fanGeometry = new THREE.CapsuleGeometry(0.4, 1.2, 4, 8);
                const fanMaterials = [
                    new THREE.MeshPhongMaterial({
                        color: 0xBF5700, // Burnt orange for home team
                        emissive: 0x441100,
                        emissiveIntensity: 0.1
                    }),
                    new THREE.MeshPhongMaterial({
                        color: 0x002244, // Navy for away team
                        emissive: 0x000033,
                        emissiveIntensity: 0.1
                    }),
                    new THREE.MeshPhongMaterial({
                        color: 0x666666, // Neutral gray
                        emissive: 0x111111,
                        emissiveIntensity: 0.05
                    })
                ];

                sectionConfigs.forEach(config => {
                    const section = {
                        name: config.name,
                        fans: [],
                        instancedMesh: null,
                        teamAffinity: config.teamAffinity
                    };

                    // Calculate total fans for this section
                    const fanCount = config.rows * config.cols;

                    // Create instanced mesh for this section
                    const material = config.teamAffinity === 'home' ? fanMaterials[0] :
                                   config.teamAffinity === 'away' ? fanMaterials[1] :
                                   fanMaterials[2];

                    section.instancedMesh = new THREE.InstancedMesh(fanGeometry, material, fanCount);
                    section.instancedMesh.castShadow = true;
                    section.instancedMesh.receiveShadow = true;

                    // Position each fan in the section
                    let fanIndex = 0;
                    const seatSpacing = 2.0;
                    const rowHeight = 1.5;

                    for (let row = 0; row < config.rows; row++) {
                        for (let col = 0; col < config.cols; col++) {
                            const fan = {
                                id: fanIndex,
                                position: new THREE.Vector3(
                                    config.x + (col - config.cols / 2) * seatSpacing,
                                    config.y + row * rowHeight,
                                    config.z + (row * 0.5) // Stadium slope
                                ),
                                rotation: new THREE.Euler(0, Math.atan2(-config.x, -config.z), 0),
                                scale: 0.8 + Math.random() * 0.4, // Vary fan sizes
                                animationState: 'idle',
                                animationPhase: Math.random() * Math.PI * 2,
                                enthusiasm: 0.5 + Math.random() * 0.5,
                                jumpHeight: 0,
                                armAngle: 0,
                                personalityType: Math.random() > 0.7 ? 'enthusiastic' :
                                               Math.random() > 0.5 ? 'normal' : 'calm'
                            };

                            // Set initial transform for this fan
                            const matrix = new THREE.Matrix4();
                            matrix.compose(
                                fan.position,
                                new THREE.Quaternion().setFromEuler(fan.rotation),
                                new THREE.Vector3(fan.scale, fan.scale, fan.scale)
                            );
                            section.instancedMesh.setMatrixAt(fanIndex, matrix);

                            // Set color variation
                            const colorOffset = 0.8 + Math.random() * 0.4;
                            section.instancedMesh.setColorAt(fanIndex,
                                new THREE.Color(colorOffset, colorOffset, colorOffset)
                            );

                            section.fans.push(fan);
                            fanIndex++;
                        }
                    }

                    section.instancedMesh.instanceMatrix.needsUpdate = true;
                    if (section.instancedMesh.instanceColor) {
                        section.instancedMesh.instanceColor.needsUpdate = true;
                    }

                    this.scene.add(section.instancedMesh);
                    this.crowdSystem.sections.push(section);
                });

                // Create crowd control UI
                this.createCrowdControls();

                console.log('🎭 Stadium Crowd System initialized with', this.crowdSystem.totalFans, 'fans!');
            }

            createCrowdControls() {
                const controlsHtml = `
                    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                        <h4 style="color: #FFD700; margin: 0 0 10px 0;">🎭 Crowd Controls</h4>
                        <button onclick="stadiumEngine.triggerCrowdWave()"
                                style="background: linear-gradient(135deg, #BF5700, #FF8C00);
                                       color: white; border: none; padding: 8px 15px;
                                       border-radius: 5px; margin: 5px; cursor: pointer;">
                            Start Wave 🌊
                        </button>
                        <button onclick="stadiumEngine.triggerGoalCelebration()"
                                style="background: linear-gradient(135deg, #FFD700, #FFA500);
                                       color: #000; border: none; padding: 8px 15px;
                                       border-radius: 5px; margin: 5px; cursor: pointer;">
                            GOAL! 🎯
                        </button>
                        <button onclick="stadiumEngine.triggerHomeRun()"
                                style="background: linear-gradient(135deg, #9E1B32, #DC143C);
                                       color: white; border: none; padding: 8px 15px;
                                       border-radius: 5px; margin: 5px; cursor: pointer;">
                            Home Run! ⚾
                        </button>
                        <div style="margin-top: 10px;">
                            <label style="color: #9BCBEB;">Excitement Level:</label>
                            <input type="range" min="0" max="100" value="50"
                                   id="crowdExcitement"
                                   onchange="stadiumEngine.setCrowdExcitement(this.value / 100)"
                                   style="width: 100%; margin-top: 5px;">
                        </div>
                    </div>
                `;

                const controls = document.querySelector('.scene-controls');
                if (controls) {
                    controls.insertAdjacentHTML('beforeend', controlsHtml);
                }
            }

            updateCrowdAnimation() {
                if (!this.crowdSystem || !this.crowdSystem.active) return;

                const time = Date.now() * 0.001;

                this.crowdSystem.sections.forEach(section => {
                    section.fans.forEach((fan, index) => {
                        const matrix = new THREE.Matrix4();
                        let position = fan.position.clone();
                        let rotation = fan.rotation.clone();

                        // Base idle animation (subtle swaying)
                        const idleSway = Math.sin(time * 2 + fan.animationPhase) * 0.02;
                        rotation.z = idleSway * fan.enthusiasm;

                        // Animation based on state
                        if (fan.animationState === 'wave' && this.crowdSystem.waveActive) {
                            // Calculate if this fan should be standing for the wave
                            const waveProgress = (time * this.crowdSystem.waveSpeed) % (Math.PI * 2);
                            const fanWavePhase = (fan.position.x + 150) / 300 * Math.PI * 2;
                            const waveHeight = Math.max(0, Math.sin(waveProgress - fanWavePhase));

                            if (waveHeight > 0.3) {
                                position.y += waveHeight * 3;
                                fan.armAngle = waveHeight * Math.PI;
                                rotation.z = Math.sin(waveProgress * 2) * 0.1;
                            }
                        } else if (fan.animationState === 'cheer') {
                            // Jumping and arm raising
                            const jumpPhase = Math.sin(time * 8 + fan.animationPhase);
                            if (jumpPhase > 0) {
                                position.y += jumpPhase * 2 * fan.enthusiasm;
                            }
                            fan.armAngle = (Math.sin(time * 10 + fan.animationPhase) + 1) * 0.5 * Math.PI;
                            rotation.y += Math.sin(time * 5) * 0.2;
                        } else if (fan.animationState === 'jump') {
                            // Synchronized jumping for goals
                            const jumpSync = Math.sin(time * 6);
                            if (jumpSync > 0) {
                                position.y += jumpSync * 3 * fan.enthusiasm;
                                rotation.x = jumpSync * 0.1;
                            }
                        } else if (fan.animationState === 'clap') {
                            // Rhythmic clapping
                            const clapPhase = Math.sin(time * 12 + fan.animationPhase * 0.2);
                            fan.armAngle = Math.abs(clapPhase) * 0.3;
                            rotation.z = clapPhase * 0.05;
                        }

                        // Add some random movement for realism
                        if (Math.random() > 0.998) {
                            fan.animationState = ['idle', 'clap', 'cheer'][Math.floor(Math.random() * 3)];
                        }

                        // Apply excitement multiplier
                        position.y += Math.sin(time * 3 + fan.animationPhase) *
                                     this.crowdSystem.excitement * 0.5 * fan.enthusiasm;

                        // Update the instance matrix
                        matrix.compose(
                            position,
                            new THREE.Quaternion().setFromEuler(rotation),
                            new THREE.Vector3(fan.scale, fan.scale, fan.scale)
                        );
                        section.instancedMesh.setMatrixAt(index, matrix);

                        // Update color based on excitement
                        if (this.crowdSystem.excitement > 0.7) {
                            const excitedColor = section.teamAffinity === 'home' ?
                                new THREE.Color(1, 0.5 + Math.sin(time * 10) * 0.2, 0) :
                                new THREE.Color(0, 0.2, 0.8 + Math.sin(time * 10) * 0.2);
                            section.instancedMesh.setColorAt(index, excitedColor);
                        }
                    });

                    section.instancedMesh.instanceMatrix.needsUpdate = true;
                    if (section.instancedMesh.instanceColor) {
                        section.instancedMesh.instanceColor.needsUpdate = true;
                    }
                });

                // Auto-decay excitement
                this.crowdSystem.excitement *= 0.995;
                this.crowdSystem.excitement = Math.max(0.3, this.crowdSystem.excitement);
            }

            triggerCrowdWave() {
                console.log('🌊 Starting stadium wave!');
                this.crowdSystem.waveActive = true;
                this.crowdSystem.sections.forEach(section => {
                    section.fans.forEach(fan => {
                        fan.animationState = 'wave';
                    });
                });

                // Stop wave after one complete rotation
                setTimeout(() => {
                    this.crowdSystem.waveActive = false;
                    this.crowdSystem.sections.forEach(section => {
                        section.fans.forEach(fan => {
                            fan.animationState = 'idle';
                        });
                    });
                }, 4000);
            }

            triggerGoalCelebration() {
                console.log('🎯 GOOOOOAL! Crowd goes wild!');
                this.crowdSystem.excitement = 1.0;
                this.crowdSystem.sections.forEach(section => {
                    if (section.teamAffinity === 'home' || section.teamAffinity === 'mixed') {
                        section.fans.forEach(fan => {
                            fan.animationState = Math.random() > 0.5 ? 'jump' : 'cheer';
                        });
                    }
                });

                // Calm down after celebration
                setTimeout(() => {
                    this.crowdSystem.sections.forEach(section => {
                        section.fans.forEach(fan => {
                            fan.animationState = 'clap';
                        });
                    });
                }, 3000);
            }

            triggerHomeRun() {
                console.log('⚾ HOME RUN! Crowd erupts!');
                this.crowdSystem.excitement = 1.0;

                // Everyone jumps!
                this.crowdSystem.sections.forEach(section => {
                    section.fans.forEach(fan => {
                        fan.animationState = 'jump';
                        // Add extra enthusiasm for home runs
                        fan.enthusiasm = Math.min(1.0, fan.enthusiasm * 1.5);
                    });
                });

                // Transition to cheering
                setTimeout(() => {
                    this.crowdSystem.sections.forEach(section => {
                        section.fans.forEach(fan => {
                            fan.animationState = 'cheer';
                        });
                    });
                }, 2000);
            }

            setCrowdExcitement(level) {
                this.crowdSystem.excitement = level;
                console.log('🎭 Crowd excitement set to', (level * 100).toFixed(0) + '%');
            }

            // 🌅 CHAMPIONSHIP HDR ENVIRONMENTAL LIGHTING - Photorealistic illumination
            createHDREnvironment() {
                console.log('🌅 Initializing HDR Environmental Lighting System...');

                this.hdrSystem = {
                    active: true,
                    timeOfDay: 14.0, // 2 PM default
                    sunPosition: new THREE.Vector3(),
                    sunColor: new THREE.Color(),
                    skyColor: new THREE.Color(),
                    groundColor: new THREE.Color(),
                    fogColor: new THREE.Color(),
                    exposure: 1.0,
                    toneMappingType: THREE.ACESFilmicToneMapping,
                    shadowCascades: 3,
                    environmentMap: null,
                    sunLight: null,
                    skyLight: null,
                    ambientLight: null
                };

                // Configure renderer for HDR
                this.renderer.toneMapping = this.hdrSystem.toneMappingType;
                this.renderer.toneMappingExposure = this.hdrSystem.exposure;
                this.renderer.physicallyCorrectLights = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.renderer.shadowMap.autoUpdate = true;
                this.renderer.shadowMap.needsUpdate = true;

                // Create dynamic sun light
                this.hdrSystem.sunLight = new THREE.DirectionalLight(0xffffff, 3.5);
                this.hdrSystem.sunLight.castShadow = true;

                // Ultra-high quality shadows
                this.hdrSystem.sunLight.shadow.mapSize.width = 4096;
                this.hdrSystem.sunLight.shadow.mapSize.height = 4096;
                this.hdrSystem.sunLight.shadow.camera.near = 0.5;
                this.hdrSystem.sunLight.shadow.camera.far = 500;
                this.hdrSystem.sunLight.shadow.camera.left = -200;
                this.hdrSystem.sunLight.shadow.camera.right = 200;
                this.hdrSystem.sunLight.shadow.camera.top = 200;
                this.hdrSystem.sunLight.shadow.camera.bottom = -200;
                this.hdrSystem.sunLight.shadow.bias = -0.0005;
                this.hdrSystem.sunLight.shadow.normalBias = 0.02;

                this.scene.add(this.hdrSystem.sunLight);
                this.scene.add(this.hdrSystem.sunLight.target);

                // Create sky hemisphere light
                this.hdrSystem.skyLight = new THREE.HemisphereLight(0x87CEEB, 0x2d5016, 0.8);
                this.scene.add(this.hdrSystem.skyLight);

                // Create ambient light for fill
                this.hdrSystem.ambientLight = new THREE.AmbientLight(0x404040, 0.3);
                this.scene.add(this.hdrSystem.ambientLight);

                // Create procedural sky
                this.createProceduralSky();

                // Create HDR control UI
                this.createHDRControls();

                // Initialize time of day
                this.updateTimeOfDay(this.hdrSystem.timeOfDay);

                console.log('🌅 HDR Environmental Lighting System initialized!');
            }

            createProceduralSky() {
                // Procedural sky dome with gradient
                const skyGeometry = new THREE.SphereGeometry(400, 32, 15);
                const skyMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        topColor: { value: new THREE.Color(0x0077ff) },
                        bottomColor: { value: new THREE.Color(0xffffff) },
                        offset: { value: 33 },
                        exponent: { value: 0.6 },
                        sunPosition: { value: new THREE.Vector3() }
                    },
                    vertexShader: `
                        varying vec3 vWorldPosition;
                        varying vec3 vSunDirection;
                        uniform vec3 sunPosition;
                        void main() {
                            vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                            vWorldPosition = worldPosition.xyz;
                            vSunDirection = normalize(sunPosition - worldPosition.xyz);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 topColor;
                        uniform vec3 bottomColor;
                        uniform float offset;
                        uniform float exponent;
                        varying vec3 vWorldPosition;
                        varying vec3 vSunDirection;

                        void main() {
                            float h = normalize(vWorldPosition + offset).y;
                            float sunIntensity = pow(max(0.0, dot(normalize(vWorldPosition), vSunDirection)), 50.0);

                            vec3 skyColor = mix(bottomColor, topColor, max(pow(max(h, 0.0), exponent), 0.0));
                            vec3 sunColor = vec3(1.0, 0.8, 0.4) * sunIntensity * 5.0;

                            gl_FragColor = vec4(skyColor + sunColor, 1.0);
                        }
                    `,
                    side: THREE.BackSide
                });

                this.hdrSystem.skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
                this.scene.add(this.hdrSystem.skyDome);
            }

            createHDRControls() {
                const controlsHtml = `
                    <div style="margin-top: 10px; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 8px;">
                        <h4 style="color: #FFD700; margin: 0 0 10px 0;">🌅 HDR Lighting</h4>
                        <label style="color: #9BCBEB;">Time of Day:</label>
                        <input type="range" min="0" max="24" step="0.1" value="14"
                               id="timeOfDay"
                               onchange="stadiumEngine.updateTimeOfDay(this.value)"
                               style="width: 100%; margin: 5px 0;">
                        <span id="timeDisplay" style="color: #FFD700;">2:00 PM</span>

                        <div style="margin-top: 10px;">
                            <button onclick="stadiumEngine.playDayCycle()"
                                    style="background: linear-gradient(135deg, #FFA500, #FF4500);
                                           color: white; border: none; padding: 8px 15px;
                                           border-radius: 5px; margin: 5px; cursor: pointer;">
                                Animate Day Cycle 🌞
                            </button>
                            <button onclick="stadiumEngine.setGoldenHour()"
                                    style="background: linear-gradient(135deg, #FFD700, #FF8C00);
                                           color: #000; border: none; padding: 8px 15px;
                                           border-radius: 5px; margin: 5px; cursor: pointer;">
                                Golden Hour 🌅
                            </button>
                        </div>

                        <div style="margin-top: 10px;">
                            <label style="color: #9BCBEB;">Exposure:</label>
                            <input type="range" min="0" max="3" step="0.1" value="1"
                                   id="exposure"
                                   onchange="stadiumEngine.setExposure(this.value)"
                                   style="width: 100%; margin-top: 5px;">
                        </div>
                    </div>
                `;

                const controls = document.querySelector('.scene-controls');
                if (controls) {
                    controls.insertAdjacentHTML('beforeend', controlsHtml);
                }
            }

            updateTimeOfDay(hour) {
                this.hdrSystem.timeOfDay = parseFloat(hour);

                // Calculate sun position based on time
                const dayProgress = hour / 24;
                const sunAngle = dayProgress * Math.PI * 2 - Math.PI / 2;
                const sunHeight = Math.sin((dayProgress - 0.25) * Math.PI * 2);

                this.hdrSystem.sunPosition.set(
                    Math.cos(sunAngle) * 150,
                    Math.max(5, sunHeight * 100),
                    Math.sin(sunAngle) * 150
                );

                // Update sun light position
                this.hdrSystem.sunLight.position.copy(this.hdrSystem.sunPosition);
                this.hdrSystem.sunLight.target.position.set(0, 0, 0);

                // Calculate lighting colors based on time of day
                let sunIntensity, sunColor, skyColor, groundColor, fogColor;

                if (hour < 5 || hour > 21) {
                    // Night
                    sunIntensity = 0.1;
                    sunColor = new THREE.Color(0x4444ff);
                    skyColor = new THREE.Color(0x000033);
                    groundColor = new THREE.Color(0x000011);
                    fogColor = new THREE.Color(0x000022);
                } else if (hour < 7) {
                    // Dawn
                    const dawn = (hour - 5) / 2;
                    sunIntensity = 0.5 + dawn * 2;
                    sunColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xff4400),
                        new THREE.Color(0xffaa00),
                        dawn
                    );
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x0a0a2a),
                        new THREE.Color(0x87ceeb),
                        dawn
                    );
                    groundColor = new THREE.Color(0x2d3561);
                    fogColor = skyColor.clone();
                } else if (hour < 17) {
                    // Day
                    sunIntensity = 3.5;
                    sunColor = new THREE.Color(0xffffff);
                    skyColor = new THREE.Color(0x87ceeb);
                    groundColor = new THREE.Color(0x2d5016);
                    fogColor = new THREE.Color(0xc0d8ff);

                    // Noon peak brightness
                    if (hour > 11 && hour < 14) {
                        sunIntensity = 4.0;
                        sunColor = new THREE.Color(0xfffdf0);
                    }
                } else if (hour < 19) {
                    // Golden hour
                    const golden = (hour - 17) / 2;
                    sunIntensity = 3 - golden * 1.5;
                    sunColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xffeeaa),
                        new THREE.Color(0xff8844),
                        golden
                    );
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x87ceeb),
                        new THREE.Color(0xff9966),
                        golden
                    );
                    groundColor = new THREE.Color(0x4d3016);
                    fogColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xc0d8ff),
                        new THREE.Color(0xffaa88),
                        golden
                    );
                } else {
                    // Dusk
                    const dusk = (hour - 19) / 2;
                    sunIntensity = 1.5 - dusk * 1.2;
                    sunColor = new THREE.Color().lerpColors(
                        new THREE.Color(0xff4488),
                        new THREE.Color(0x4444ff),
                        dusk
                    );
                    skyColor = new THREE.Color().lerpColors(
                        new THREE.Color(0x663388),
                        new THREE.Color(0x000033),
                        dusk
                    );
                    groundColor = new THREE.Color(0x1a1a2e);
                    fogColor = skyColor.clone();
                }

                // Apply calculated lighting
                this.hdrSystem.sunLight.intensity = sunIntensity;
                this.hdrSystem.sunLight.color = sunColor;
                this.hdrSystem.skyLight.color = skyColor;
                this.hdrSystem.skyLight.groundColor = groundColor;
                this.hdrSystem.ambientLight.color = skyColor.clone().multiplyScalar(0.3);

                // Update fog
                if (this.scene.fog) {
                    this.scene.fog.color = fogColor;
                }

                // Update sky dome
                if (this.hdrSystem.skyDome) {
                    this.hdrSystem.skyDome.material.uniforms.topColor.value = skyColor;
                    this.hdrSystem.skyDome.material.uniforms.bottomColor.value = fogColor;
                    this.hdrSystem.skyDome.material.uniforms.sunPosition.value = this.hdrSystem.sunPosition;
                }

                // Update shadow cascades for optimal quality
                this.updateShadowCascades();

                // Update time display
                const displayHour = Math.floor(hour);
                const displayMinute = Math.floor((hour - displayHour) * 60);
                const ampm = displayHour >= 12 ? 'PM' : 'AM';
                const display12Hour = displayHour > 12 ? displayHour - 12 : (displayHour === 0 ? 12 : displayHour);
                document.getElementById('timeDisplay').textContent =
                    `${display12Hour}:${displayMinute.toString().padStart(2, '0')} ${ampm}`;
            }

            updateShadowCascades() {
                // Adjust shadow camera based on sun height for optimal shadow quality
                const sunHeight = this.hdrSystem.sunPosition.y;

                if (sunHeight > 50) {
                    // High sun - tighter shadow bounds
                    this.hdrSystem.sunLight.shadow.camera.left = -150;
                    this.hdrSystem.sunLight.shadow.camera.right = 150;
                    this.hdrSystem.sunLight.shadow.camera.top = 150;
                    this.hdrSystem.sunLight.shadow.camera.bottom = -150;
                } else if (sunHeight > 20) {
                    // Medium sun - standard bounds
                    this.hdrSystem.sunLight.shadow.camera.left = -200;
                    this.hdrSystem.sunLight.shadow.camera.right = 200;
                    this.hdrSystem.sunLight.shadow.camera.top = 200;
                    this.hdrSystem.sunLight.shadow.camera.bottom = -200;
                } else {
                    // Low sun - extended bounds for long shadows
                    this.hdrSystem.sunLight.shadow.camera.left = -300;
                    this.hdrSystem.sunLight.shadow.camera.right = 300;
                    this.hdrSystem.sunLight.shadow.camera.top = 300;
                    this.hdrSystem.sunLight.shadow.camera.bottom = -300;
                }

                this.hdrSystem.sunLight.shadow.camera.updateProjectionMatrix();
            }

            playDayCycle() {
                console.log('🌞 Starting day cycle animation...');
                const startTime = this.hdrSystem.timeOfDay;
                const duration = 10000; // 10 seconds for full day
                const startTimestamp = Date.now();

                const animateDayCycle = () => {
                    const elapsed = Date.now() - startTimestamp;
                    const progress = elapsed / duration;

                    if (progress < 1) {
                        const currentHour = (startTime + progress * 24) % 24;
                        this.updateTimeOfDay(currentHour);
                        document.getElementById('timeOfDay').value = currentHour;
                        requestAnimationFrame(animateDayCycle);
                    } else {
                        this.updateTimeOfDay(startTime);
                        document.getElementById('timeOfDay').value = startTime;
                        console.log('🌙 Day cycle complete');
                    }
                };

                animateDayCycle();
            }

            setGoldenHour() {
                console.log('🌅 Setting golden hour lighting...');
                this.updateTimeOfDay(17.5); // 5:30 PM
                document.getElementById('timeOfDay').value = 17.5;
            }

            setExposure(value) {
                this.hdrSystem.exposure = parseFloat(value);
                this.renderer.toneMappingExposure = this.hdrSystem.exposure;
                console.log('📸 Exposure set to', this.hdrSystem.exposure.toFixed(1));
            }

            animate() {
                // 🎬 Update cinematic camera first (overrides controls)
                this.updateCinematicCamera();

                // Update controls only if cinematic mode is not active
                if (this.controls && !this.cinematicCamera.isActive) {
                    this.controls.update();
                }

                // ⚡ Advanced physics particle simulation
                if (this.stadium.particles && this.particlePhysics) {
                    const time = Date.now() * 0.001;
                    const positions = this.stadium.particles.geometry.attributes.position.array;
                    const colors = this.stadium.particles.geometry.attributes.color.array;
                    const sizes = this.stadium.particles.geometry.attributes.size.array;
                    const userData = this.stadium.particles.geometry.userData;
                    const velocities = userData.velocities;
                    const accelerations = userData.accelerations;
                    const ages = userData.ages;
                    const lifespans = userData.lifespans;
                    const masses = userData.masses;

                    // Dynamic environmental forces
                    const windStrength = 0.5 + Math.sin(time * 0.3) * 0.3;
                    const windDirection = new THREE.Vector3(
                        Math.sin(time * 0.1) * windStrength * 0.002,
                        0,
                        Math.cos(time * 0.15) * windStrength * 0.001
                    );

                    for (let i = 0; i < positions.length; i += 3) {
                        const particleIndex = i / 3;
                        const mass = masses[particleIndex];

                        // Reset accelerations
                        accelerations[i] = 0;
                        accelerations[i + 1] = 0;
                        accelerations[i + 2] = 0;

                        // Apply gravity (affected by mass)
                        accelerations[i + 1] += this.particlePhysics.gravity.y * mass;

                        // Apply wind forces (lighter particles more affected)
                        const windEffect = (2.0 - mass) / 2.0; // Inverse mass for wind effect
                        accelerations[i] += windDirection.x * windEffect;
                        accelerations[i + 1] += windDirection.y * windEffect * 0.5;
                        accelerations[i + 2] += windDirection.z * windEffect;

                        // Stadium lighting attraction (championship glow effect)
                        const distanceFromCenter = Math.sqrt(positions[i] * positions[i] + positions[i + 2] * positions[i + 2]);
                        if (distanceFromCenter > 50) {
                            const attractionForce = 0.0001 * (distanceFromCenter - 50) / distanceFromCenter;
                            accelerations[i] -= positions[i] * attractionForce;
                            accelerations[i + 2] -= positions[i + 2] * attractionForce;
                        }

                        // Update velocities with physics
                        velocities[i] += accelerations[i];
                        velocities[i + 1] += accelerations[i + 1];
                        velocities[i + 2] += accelerations[i + 2];

                        // Apply damping
                        velocities[i] *= this.particlePhysics.damping;
                        velocities[i + 1] *= this.particlePhysics.damping;
                        velocities[i + 2] *= this.particlePhysics.damping;

                        // Update positions
                        positions[i] += velocities[i];
                        positions[i + 1] += velocities[i + 1];
                        positions[i + 2] += velocities[i + 2];

                        // Advanced collision detection with stadium bounds
                        const bounds = this.particlePhysics.fieldBounds;

                        // Ground collision with bounce
                        if (positions[i + 1] <= bounds.min.y) {
                            positions[i + 1] = bounds.min.y;
                            velocities[i + 1] = Math.abs(velocities[i + 1]) * 0.6; // Bounce with energy loss
                            velocities[i] *= 0.8; // Friction
                            velocities[i + 2] *= 0.8;
                        }

                        // Boundary collisions with realistic physics
                        if (positions[i] <= bounds.min.x || positions[i] >= bounds.max.x) {
                            velocities[i] *= -0.7;
                            positions[i] = Math.max(bounds.min.x, Math.min(bounds.max.x, positions[i]));
                        }
                        if (positions[i + 2] <= bounds.min.z || positions[i + 2] >= bounds.max.z) {
                            velocities[i + 2] *= -0.7;
                            positions[i + 2] = Math.max(bounds.min.z, Math.min(bounds.max.z, positions[i + 2]));
                        }

                        // Particle aging and lifecycle
                        ages[particleIndex] += 1;
                        const lifeRatio = ages[particleIndex] / lifespans[particleIndex];

                        // Fade out near end of life
                        const alpha = lifeRatio < 0.8 ? 1.0 : (1.0 - lifeRatio) * 5.0;
                        colors[i] *= alpha;
                        colors[i + 1] *= alpha;
                        colors[i + 2] *= alpha;

                        // Size variation based on life and altitude
                        const altitudeFactor = Math.max(0.3, (positions[i + 1] - bounds.min.y) / 50);
                        sizes[particleIndex] = (mass * 3 + Math.sin(time + particleIndex * 0.1) * 0.5) * altitudeFactor;

                        // Respawn particle if too old or out of bounds
                        if (ages[particleIndex] > lifespans[particleIndex] || positions[i + 1] > bounds.max.y) {
                            this.respawnParticle(particleIndex, positions, velocities, ages, lifespans, masses, colors, sizes);
                        }
                    }

                    // Update geometry attributes
                    this.stadium.particles.geometry.attributes.position.needsUpdate = true;
                    this.stadium.particles.geometry.attributes.color.needsUpdate = true;
                    this.stadium.particles.geometry.attributes.size.needsUpdate = true;
                }

                // Stadium lights animation
                this.lighting.stadium.forEach((light, index) => {
                    const time = Date.now() * 0.001;
                    light.intensity = this.isLightingEnabled ?
                        1.2 + Math.sin(time * 0.5 + index) * 0.1 : 0.2;
                });

                // 🌱 Advanced field shader animation
                if (this.advancedFieldMaterial) {
                    const time = Date.now() * 0.001;
                    this.advancedFieldMaterial.uniforms.uTime.value = time;

                    // Dynamic grass conditions based on lighting
                    const avgLightIntensity = this.lighting.stadium.reduce((sum, light) =>
                        sum + light.intensity, 0) / this.lighting.stadium.length;
                    this.advancedFieldMaterial.uniforms.uMoisture.value = 0.4 + Math.sin(time * 0.1) * 0.2;
                    this.advancedFieldMaterial.uniforms.uWindStrength.value = 0.3 + Math.sin(time * 0.3) * 0.1;
                }

                // 🏆 Advanced goalpost shader animation
                if (this.advancedGoalpostMaterial) {
                    const time = Date.now() * 0.001;
                    this.advancedGoalpostMaterial.uniforms.uTime.value = time;

                    // Weather-based rust and wear effects
                    const weatherFactor = 0.5 + Math.sin(time * 0.05) * 0.5;
                    this.advancedGoalpostMaterial.uniforms.uRustAmount.value = 0.1 + weatherFactor * 0.1;
                    this.advancedGoalpostMaterial.uniforms.uWearAmount.value = 0.15 + Math.sin(time * 0.08) * 0.05;
                }

                // Update vertex count
                this.stats.vertices = this.scene.children.reduce((count, child) => {
                    if (child.geometry) {
                        const positions = child.geometry.attributes.position;
                        return count + (positions ? positions.count : 0);
                    }
                    return count;
                }, 0) / 1000;

                document.getElementById('verticesCount').textContent = `Verts: ${this.stats.vertices.toFixed(1)}k`;

                // 🌦️ Update Dynamic Weather System
                if (this.weatherSystem && this.weatherSystem.active) {
                    this.updateWeatherSystem();
                }

                // 🎭 Update Animated Stadium Crowd
                if (this.crowdSystem && this.crowdSystem.active) {
                    this.updateCrowdAnimation();
                }

                // 🎬 Render with Championship Post-Processing Pipeline
                if (this.postProcessingEnabled && this.composer) {
                    // Dynamic bloom intensity based on lighting
                    if (this.bloomPass) {
                        const avgLightIntensity = this.lighting.stadium.reduce((sum, light) =>
                            sum + light.intensity, 0) / this.lighting.stadium.length;
                        this.bloomPass.strength = 0.8 + avgLightIntensity * 0.4;
                    }

                    // Dynamic chromatic aberration for cinematic effect
                    if (this.chromaticPass) {
                        const time = Date.now() * 0.001;
                        this.chromaticPass.uniforms.amount.value = 0.0015 + Math.sin(time * 0.3) * 0.0005;
                        this.chromaticPass.uniforms.angle.value = Math.sin(time * 0.2) * 0.1;
                    }

                    this.composer.render();
                } else {
                    // Fallback to standard rendering for lower-end devices
                    this.renderer.render(this.scene, this.camera);
                }
            }

            startRenderLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    this.animate();
                };
                animate();
            }

            destroy() {
                if (this.controls) this.controls.dispose();
                if (this.renderer) this.renderer.dispose();
                console.log('🏆 Championship Stadium Engine destroyed');
            }
        }

        // Initialize the Championship Stadium Engine
        let stadiumEngine = null;

        function initialize3DVisualization() {
            stadiumEngine = new ChampionshipStadiumEngine();
        }

        // ===== LIVE METRICS ANIMATION =====
        function animateMetrics() {
            const metrics = {
                accuracy: document.getElementById('accuracyMetric'),
                teams: document.getElementById('teamsMetric'),
                uptime: document.getElementById('uptimeMetric'),
                latency: document.getElementById('latencyMetric')
            };

            // Simulate live data updates
            setInterval(() => {
                const accuracy = (70 + Math.random() * 5).toFixed(1);
                const uptime = (99 + Math.random() * 0.9).toFixed(1);
                const latency = Math.floor(85 + Math.random() * 20);

                metrics.accuracy.textContent = accuracy + '%';
                metrics.uptime.textContent = uptime + '%';
                metrics.latency.textContent = latency + 'ms';

                // Add flash effect
                [metrics.accuracy, metrics.uptime, metrics.latency].forEach(el => {
                    el.style.color = '#FFD700';
                    setTimeout(() => el.style.color = '#FFD700', 300);
                });
            }, 5000);
        }

        // ===== NIL CALCULATOR SYSTEM =====
        function initializeNILCalculator() {
            const performanceSlider = document.getElementById('nilPerformance');
            const performanceDisplay = document.getElementById('performanceDisplay');
            const calculateBtn = document.getElementById('calculateNilBtn');
            const resultDiv = document.getElementById('nilResult');
            const nilValue = document.getElementById('nilValue');

            // Update performance display
            performanceSlider.addEventListener('input', (e) => {
                performanceDisplay.textContent = `${e.target.value}/10`;
            });

            // NIL calculation with enhanced algorithm
            calculateBtn.addEventListener('click', () => {
                const sport = document.getElementById('nilSport').value;
                const followers = parseInt(document.getElementById('nilFollowers').value) || 0;
                const performance = parseInt(performanceSlider.value);

                // Enhanced NIL calculation algorithm
                const sportMultipliers = {
                    football: { base: 85000, multiplier: 1.3 },
                    basketball: { base: 65000, multiplier: 1.2 },
                    baseball: { base: 35000, multiplier: 1.0 },
                    track: { base: 25000, multiplier: 0.8 }
                };

                const sportData = sportMultipliers[sport] || sportMultipliers.football;
                const followerMultiplier = Math.min(Math.log10(followers + 1) / 4, 2.8);
                const performanceMultiplier = Math.pow(performance / 10, 1.6);
                const marketMultiplier = sport === 'football' ? 1.15 : sport === 'basketball' ? 1.05 : 1.0;

                const calculatedValue = Math.round(
                    sportData.base *
                    sportData.multiplier *
                    (1 + followerMultiplier) *
                    performanceMultiplier *
                    marketMultiplier
                );

                // Animate the result
                calculateBtn.disabled = true;
                calculateBtn.textContent = 'Calculating...';

                setTimeout(() => {
                    // Animate number count-up
                    gsap.to({ value: 0 }, {
                        duration: 2.5,
                        value: calculatedValue,
                        ease: "power2.out",
                        onUpdate: function() {
                            nilValue.textContent = `$${Math.round(this.targets()[0].value).toLocaleString()}`;
                        },
                        onComplete: () => {
                            calculateBtn.disabled = false;
                            calculateBtn.textContent = 'Calculate NIL Value';
                        }
                    });

                    resultDiv.style.opacity = '1';

                    // Add glow effect
                    gsap.to(resultDiv, {
                        duration: 0.5,
                        boxShadow: '0 0 30px rgba(255, 215, 0, 0.3)',
                        ease: 'power2.out'
                    });

                    console.log(`💰 NIL calculated for ${sport}: $${calculatedValue.toLocaleString()}`);
                }, 500);
            });
        }

        // ===== LIVE DATA INTEGRATION =====
        function initializeLiveData() {
            // Simulate live sports data updates
            const updateLiveMetrics = () => {
                // Simulate realistic data fluctuations
                const metrics = {
                    accuracy: 70 + Math.sin(Date.now() * 0.0001) * 5 + Math.random() * 2,
                    teams: 153 + Math.floor(Math.random() * 7) - 3,
                    uptime: 99 + Math.random() * 0.9,
                    latency: 85 + Math.sin(Date.now() * 0.0002) * 15 + Math.random() * 10
                };

                // Update with smooth transitions
                gsap.to('#accuracyMetric', {
                    duration: 1,
                    innerText: metrics.accuracy.toFixed(1) + '%',
                    ease: 'power2.out'
                });

                gsap.to('#teamsMetric', {
                    duration: 1,
                    innerText: Math.round(metrics.teams),
                    ease: 'power2.out'
                });

                gsap.to('#uptimeMetric', {
                    duration: 1,
                    innerText: metrics.uptime.toFixed(1) + '%',
                    ease: 'power2.out'
                });

                gsap.to('#latencyMetric', {
                    duration: 1,
                    innerText: Math.round(metrics.latency) + 'ms',
                    ease: 'power2.out'
                });

                // Visual feedback
                const metricElements = document.querySelectorAll('.metric-value');
                metricElements.forEach(el => {
                    gsap.to(el, {
                        duration: 0.2,
                        color: '#FFD700',
                        ease: 'power2.out',
                        yoyo: true,
                        repeat: 1
                    });
                });
            };

            // Update every 5 seconds
            setInterval(updateLiveMetrics, 5000);

            console.log('📊 Live data integration initialized');
        }

        // ===== ENHANCED PARTICLE SYSTEM =====
        function initializeEnhancedParticles() {
            const canvas = document.getElementById('particleCanvas');
            if (!canvas) return;

            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            const particles = [];
            const particleCount = 75;
            const connectionDistance = 150;

            class EnhancedParticle {
                constructor() {
                    this.x = Math.random() * canvas.width;
                    this.y = Math.random() * canvas.height;
                    this.vx = (Math.random() - 0.5) * 0.8;
                    this.vy = (Math.random() - 0.5) * 0.8;
                    this.size = Math.random() * 3 + 1;
                    this.opacity = Math.random() * 0.6 + 0.3;
                    this.hue = Math.random() * 60 + 20; // Orange to gold range
                }

                update() {
                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                    if (this.y < 0 || this.y > canvas.height) this.vy *= -1;

                    // Slight orbital motion
                    this.x += Math.sin(Date.now() * 0.001 + this.x * 0.001) * 0.2;
                    this.y += Math.cos(Date.now() * 0.001 + this.y * 0.001) * 0.2;
                }

                draw() {
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${this.hue}, 80%, 60%, ${this.opacity})`;
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = `hsl(${this.hue}, 80%, 60%)`;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }

                drawConnections(otherParticles) {
                    otherParticles.forEach(particle => {
                        const dx = this.x - particle.x;
                        const dy = this.y - particle.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance < connectionDistance) {
                            const opacity = (1 - distance / connectionDistance) * 0.3;
                            ctx.beginPath();
                            ctx.moveTo(this.x, this.y);
                            ctx.lineTo(particle.x, particle.y);
                            ctx.strokeStyle = `rgba(191, 87, 0, ${opacity})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    });
                }
            }

            // Create particles
            for (let i = 0; i < particleCount; i++) {
                particles.push(new EnhancedParticle());
            }

            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Update and draw particles
                particles.forEach((particle, index) => {
                    particle.update();
                    particle.draw();
                    particle.drawConnections(particles.slice(index + 1));
                });

                requestAnimationFrame(animate);
            }

            animate();

            // Resize handler
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            console.log('✨ Enhanced particle system initialized');
        }

        // ===== INTERACTIVE EFFECTS =====
        function initializeInteractiveEffects() {
            // Smooth hover effects for dashboard cards
            document.querySelectorAll('.dashboard-card').forEach(card => {
                card.addEventListener('mouseenter', () => {
                    gsap.to(card, {
                        duration: 0.3,
                        scale: 1.02,
                        boxShadow: '0 20px 60px rgba(191, 87, 0, 0.2)',
                        ease: 'power2.out'
                    });
                });

                card.addEventListener('mouseleave', () => {
                    gsap.to(card, {
                        duration: 0.3,
                        scale: 1,
                        boxShadow: '0 20px 40px rgba(0, 0, 0, 0.3)',
                        ease: 'power2.out'
                    });
                });
            });

            // Metric item interactions
            document.querySelectorAll('.metric-item').forEach(item => {
                item.addEventListener('mouseenter', () => {
                    gsap.to(item, {
                        duration: 0.2,
                        scale: 1.08,
                        background: 'var(--glass-accent)',
                        ease: 'power2.out'
                    });
                });

                item.addEventListener('mouseleave', () => {
                    gsap.to(item, {
                        duration: 0.2,
                        scale: 1,
                        background: 'var(--glass-secondary)',
                        ease: 'power2.out'
                    });
                });
            });

            console.log('🎮 Interactive effects initialized');
        }

        // ===== CHAMPIONSHIP LOADING SEQUENCE =====
        function initializeChampionshipExperience() {
            // Sequential initialization with loading feedback
            const loaderText = document.querySelector('.loader-text div:last-child');

            const initSteps = [
                { name: 'Enhanced Particle System', fn: initializeEnhancedParticles },
                { name: 'Championship Stadium Engine', fn: initialize3DVisualization },
                { name: 'NIL Calculator', fn: initializeNILCalculator },
                { name: 'Live Data Integration', fn: initializeLiveData },
                { name: 'Interactive Effects', fn: initializeInteractiveEffects }
            ];

            let currentStep = 0;

            function runNextStep() {
                if (currentStep < initSteps.length) {
                    const step = initSteps[currentStep];
                    loaderText.textContent = `Initializing ${step.name}...`;

                    setTimeout(() => {
                        step.fn();
                        currentStep++;
                        runNextStep();
                    }, 300);
                } else {
                    loaderText.textContent = 'Championship Experience Ready!';
                    finalizePremiumExperience();
                }
            }

            runNextStep();
        }

        // ===== PREMIUM EXPERIENCE INITIALIZATION =====
        function finalizePremiumExperience() {
            // GSAP Premium Animations with enhanced timing
            const tl = gsap.timeline();

            tl.from('.hero-title', {
                duration: 1.8,
                y: 120,
                opacity: 0,
                ease: 'power4.out'
            })
            .from('.hero-subtitle', {
                duration: 1.2,
                y: 60,
                opacity: 0,
                ease: 'power3.out'
            }, '-=1.2')
            .from('.dashboard-card', {
                duration: 1.2,
                y: 80,
                opacity: 0,
                stagger: 0.15,
                ease: 'power3.out'
            }, '-=0.8')
            .from('.metric-item', {
                duration: 0.8,
                scale: 0.8,
                opacity: 0,
                stagger: 0.1,
                ease: 'back.out(1.7)'
            }, '-=0.6');

            // Initialize continuous animations
            animateMetrics();

            // Performance monitoring
            if ('PerformanceObserver' in window) {
                const observer = new PerformanceObserver((list) => {
                    list.getEntries().forEach((entry) => {
                        if (entry.entryType === 'largest-contentful-paint') {
                            console.log('🏆 LCP:', `${entry.startTime.toFixed(1)}ms`);
                        }
                        if (entry.entryType === 'first-input') {
                            const fid = entry.processingStart - entry.startTime;
                            console.log('⚡ FID:', `${fid.toFixed(1)}ms`);
                        }
                    });
                });

                observer.observe({
                    entryTypes: ['largest-contentful-paint', 'first-input']
                });
            }

            console.log('🔥 Blaze Intelligence Championship Experience Initialized');
            console.log('🏆 Revolutionary 3D Stadium Graphics Active');
            console.log('📊 Real-Time Data Streams Online');
            console.log('🎯 The Deep South Sports Authority - Premium Mode Engaged');
        }

        function initializePremiumExperience() {
            initializeChampionshipExperience();
        }

        // Revolutionary Command Center Initialization
        document.addEventListener('DOMContentLoaded', function() {
            const launchButton = document.getElementById('launch-command-center');
            let commandCenterActive = false;

            if (launchButton) {
                launchButton.addEventListener('click', function() {
                    if (!commandCenterActive) {
                        console.log('🚀 Launching Revolutionary Command Center...');

                        // Initialize command center if not already done
                        if (typeof window.blazeCommandCenter === 'undefined') {
                            console.log('⚡ Initializing Command Center Systems...');
                            // The command center auto-initializes from its own file
                        }

                        // Play championship intro sequence
                        if (window.blazeCommandCenter && window.blazeCommandCenter.isInitialized) {
                            window.blazeCommandCenter.playCinematicSequence('championship-intro');
                            console.log('🎬 Championship intro sequence started');
                        }

                        // Update button state
                        launchButton.innerHTML = `
                            <i class="fas fa-cog fa-spin"></i>
                            <span>COMMAND CENTER ACTIVE</span>
                            <div class="btn-glow"></div>
                        `;

                        launchButton.style.background = 'linear-gradient(135deg, #00B2A9, #26D5CC)';
                        launchButton.style.borderColor = '#00FF88';

                        commandCenterActive = true;

                        // Auto-launch team showcase after 5 seconds
                        setTimeout(() => {
                            if (window.blazeCommandCenter && window.blazeCommandCenter.isInitialized) {
                                window.blazeCommandCenter.playCinematicSequence('team-showcase');
                                console.log('🏆 Team showcase sequence started');
                            }
                        }, 5000);

                        // Enable voice commands notification
                        setTimeout(() => {
                            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                                console.log('🎤 Voice commands available - try "Show Cardinals" or "Championship Mode"');

                                // Show voice command hint
                                const hint = document.createElement('div');
                                hint.style.cssText = `
                                    position: fixed;
                                    top: 20px;
                                    right: 20px;
                                    background: linear-gradient(135deg, rgba(0, 178, 169, 0.95), rgba(38, 213, 204, 0.95));
                                    backdrop-filter: blur(20px);
                                    color: white;
                                    padding: 12px 20px;
                                    border-radius: 8px;
                                    font-size: 14px;
                                    font-weight: 600;
                                    z-index: 10000;
                                    animation: fadeInSlide 0.5s ease-out;
                                `;
                                hint.innerHTML = `
                                    <i class="fas fa-microphone" style="margin-right: 8px;"></i>
                                    Voice Commands Active
                                `;
                                document.body.appendChild(hint);

                                // Remove hint after 4 seconds
                                setTimeout(() => {
                                    hint.style.animation = 'fadeOutSlide 0.5s ease-out';
                                    setTimeout(() => {
                                        if (hint.parentNode) {
                                            hint.parentNode.removeChild(hint);
                                        }
                                    }, 500);
                                }, 4000);
                            }
                        }, 2000);

                    } else {
                        console.log('🎯 Command Center already active - switching to overview');

                        if (window.blazeCommandCenter && window.blazeCommandCenter.switchCameraPosition) {
                            window.blazeCommandCenter.switchCameraPosition('overview');
                        }
                    }
                });

                // Add keyboard shortcut (Ctrl/Cmd + Space)
                document.addEventListener('keydown', function(e) {
                    if ((e.ctrlKey || e.metaKey) && e.code === 'Space') {
                        e.preventDefault();
                        launchButton.click();
                    }
                });
            }

            // Performance monitoring
            let frameCount = 0;
            let lastTime = performance.now();

            function updatePerformanceMetrics() {
                const currentTime = performance.now();
                frameCount++;

                if (currentTime - lastTime >= 1000) {
                    const fps = Math.round(frameCount * 1000 / (currentTime - lastTime));

                    // Update FPS display if command center is active
                    const fpsElement = document.getElementById('current-fps');
                    if (fpsElement) {
                        fpsElement.textContent = fps;
                        fpsElement.style.color = fps >= 60 ? '#00FF88' : fps >= 45 ? '#FFAA00' : '#FF4444';
                    }

                    // Log performance if below target
                    if (fps < 60) {
                        console.log(`⚠️ Performance: ${fps} FPS (Target: 60 FPS)`);
                    }

                    frameCount = 0;
                    lastTime = currentTime;
                }

                requestAnimationFrame(updatePerformanceMetrics);
            }

            updatePerformanceMetrics();

            console.log('🏆 Revolutionary Command Center Integration Ready');
            console.log('🚀 Press Launch Button or use Ctrl+Space to activate');
        });
    </script>

    <style>
        @keyframes fadeInSlide {
            from {
                opacity: 0;
                transform: translateX(30px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        @keyframes fadeOutSlide {
            from {
                opacity: 1;
                transform: translateX(0);
            }
            to {
                opacity: 0;
                transform: translateX(30px);
            }
        }

        @keyframes status-pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.7;
                transform: scale(1.1);
            }
        }
    </style>
</body>
</html>