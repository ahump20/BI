<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blaze Intelligence - Interactive Physics Analytics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #000;
            color: #fff;
            overflow: hidden;
            cursor: crosshair;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* HUD Overlay */
        .hud {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 100;
        }

        .score-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #C41E3A;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            min-width: 250px;
            pointer-events: all;
        }

        .score-title {
            font-size: 1.5rem;
            color: #C41E3A;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(196, 30, 58, 0.8);
        }

        .team-score {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            padding: 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        .team-score:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .team-name {
            font-weight: bold;
            font-size: 1.1rem;
        }

        .team-value {
            font-size: 1.3rem;
            font-weight: bold;
        }

        .cardinals { color: #C41E3A; }
        .titans { color: #4B92DB; }
        .longhorns { color: #BF5700; }
        .grizzlies { color: #5D76A9; }

        /* Analytics Panel */
        .analytics-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid #4B92DB;
            border-radius: 10px;
            padding: 20px;
            backdrop-filter: blur(10px);
            min-width: 300px;
            pointer-events: all;
        }

        .analytics-title {
            font-size: 1.3rem;
            color: #4B92DB;
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(75, 146, 219, 0.8);
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            font-size: 0.9rem;
        }

        .stat-label {
            color: rgba(255, 255, 255, 0.7);
        }

        .stat-value {
            color: #fff;
            font-weight: bold;
        }

        /* Controls */
        .controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
            pointer-events: all;
        }

        .control-btn {
            padding: 12px 24px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #BF5700;
            color: #fff;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-btn:hover {
            background: rgba(191, 87, 0, 0.3);
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(191, 87, 0, 0.5);
        }

        /* Power meter */
        .power-meter {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            width: 300px;
            height: 30px;
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #5D76A9;
            border-radius: 15px;
            overflow: hidden;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .power-meter.active {
            opacity: 1;
        }

        .power-fill {
            height: 100%;
            background: linear-gradient(90deg, #5D76A9 0%, #C41E3A 100%);
            width: 0%;
            transition: width 0.1s ease;
            box-shadow: 0 0 20px rgba(196, 30, 58, 0.8);
        }

        /* Instructions */
        .instructions {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            opacity: 0.8;
            transition: opacity 0.5s ease;
        }

        .instructions.hidden {
            opacity: 0;
        }

        .instructions h2 {
            font-size: 2rem;
            margin-bottom: 20px;
            background: linear-gradient(135deg, #C41E3A, #4B92DB);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .instructions p {
            font-size: 1.1rem;
            margin: 10px 0;
            color: rgba(255, 255, 255, 0.8);
        }

        /* FPS Counter */
        .fps-counter {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            font-family: monospace;
            font-size: 14px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD Overlay -->
    <div class="hud">
        <!-- Score Panel -->
        <div class="score-panel">
            <div class="score-title">TEAM SCORES</div>
            <div class="team-score">
                <span class="team-name cardinals">Cardinals</span>
                <span class="team-value cardinals" id="cardinals-score">0</span>
            </div>
            <div class="team-score">
                <span class="team-name titans">Titans</span>
                <span class="team-value titans" id="titans-score">0</span>
            </div>
            <div class="team-score">
                <span class="team-name longhorns">Longhorns</span>
                <span class="team-value longhorns" id="longhorns-score">0</span>
            </div>
            <div class="team-score">
                <span class="team-name grizzlies">Grizzlies</span>
                <span class="team-value grizzlies" id="grizzlies-score">0</span>
            </div>
        </div>

        <!-- Analytics Panel -->
        <div class="analytics-panel">
            <div class="analytics-title">LIVE ANALYTICS</div>
            <div class="stat-row">
                <span class="stat-label">Active Objects:</span>
                <span class="stat-value" id="active-objects">0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Collision Rate:</span>
                <span class="stat-value" id="collision-rate">0/s</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Physics FPS:</span>
                <span class="stat-value" id="physics-fps">60</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Velocity Avg:</span>
                <span class="stat-value" id="velocity-avg">0.0</span>
            </div>
            <div class="stat-row">
                <span class="stat-label">Energy Total:</span>
                <span class="stat-value" id="energy-total">0</span>
            </div>
        </div>

        <!-- FPS Counter -->
        <div class="fps-counter">
            FPS: <span id="fps">60</span> | Draw Calls: <span id="draw-calls">0</span>
        </div>

        <!-- Power Meter -->
        <div class="power-meter" id="power-meter">
            <div class="power-fill" id="power-fill"></div>
        </div>

        <!-- Instructions -->
        <div class="instructions" id="instructions">
            <h2>BLAZE PHYSICS ARENA</h2>
            <p>Click and drag to launch team balls</p>
            <p>Hold longer for more power</p>
            <p>Collect points by hitting targets</p>
        </div>

        <!-- Controls -->
        <div class="controls">
            <button class="control-btn" onclick="resetGame()">RESET</button>
            <button class="control-btn" onclick="toggleGravity()">GRAVITY</button>
            <button class="control-btn" onclick="spawnPowerUp()">POWER UP</button>
            <button class="control-btn" onclick="toggleSlowMotion()">SLOW-MO</button>
        </div>
    </div>

    <!-- Three.js and Physics -->
    <script src="three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <script src="blaze-shaders.js"></script>
    
    <script>
        // Initialize Three.js
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x000000, 50, 200);
        
        const camera = new THREE.PerspectiveCamera(
            75,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        
        const renderer = new THREE.WebGLRenderer({
            canvas: document.getElementById('gameCanvas'),
            antialias: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Initialize Cannon.js Physics
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();
        world.solver.iterations = 10;

        // Team configurations
        const teams = {
            cardinals: { color: 0xC41E3A, score: 0 },
            titans: { color: 0x4B92DB, score: 0 },
            longhorns: { color: 0xBF5700, score: 0 },
            grizzlies: { color: 0x5D76A9, score: 0 }
        };

        // Game state
        let gameState = {
            activeObjects: [],
            collisions: 0,
            slowMotion: false,
            gravityEnabled: true,
            powerLevel: 0,
            isCharging: false,
            mouseStart: null,
            selectedTeam: 'cardinals'
        };

        // Analytics tracking
        let analytics = {
            collisionRate: 0,
            velocitySum: 0,
            energyTotal: 0,
            frameCount: 0,
            lastTime: performance.now(),
            fps: 60
        };

        // Create arena floor
        const floorGeometry = new THREE.PlaneGeometry(100, 100);
        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x111111,
            metalness: 0.8,
            roughness: 0.2
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Add grid overlay
        const gridHelper = new THREE.GridHelper(100, 50, 0x444444, 0x222222);
        scene.add(gridHelper);

        // Physics floor
        const floorShape = new CANNON.Plane();
        const floorBody = new CANNON.Body({
            mass: 0,
            shape: floorShape
        });
        floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(floorBody);

        // Create walls
        const wallThickness = 1;
        const wallHeight = 20;
        const wallLength = 100;

        function createWall(x, y, z, rotationY = 0) {
            // Three.js wall
            const wallGeometry = new THREE.BoxGeometry(
                rotationY === 0 ? wallLength : wallThickness,
                wallHeight,
                rotationY === 0 ? wallThickness : wallLength
            );
            const wallMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                transparent: true,
                opacity: 0.3,
                metalness: 0.5,
                roughness: 0.5
            });
            const wall = new THREE.Mesh(wallGeometry, wallMaterial);
            wall.position.set(x, y, z);
            wall.rotation.y = rotationY;
            wall.castShadow = true;
            wall.receiveShadow = true;
            scene.add(wall);

            // Physics wall
            const wallShape = new CANNON.Box(new CANNON.Vec3(
                rotationY === 0 ? wallLength / 2 : wallThickness / 2,
                wallHeight / 2,
                rotationY === 0 ? wallThickness / 2 : wallLength / 2
            ));
            const wallBody = new CANNON.Body({
                mass: 0,
                shape: wallShape,
                position: new CANNON.Vec3(x, y, z)
            });
            world.addBody(wallBody);
        }

        // Create arena walls
        createWall(0, wallHeight / 2, -50); // Back wall
        createWall(0, wallHeight / 2, 50);  // Front wall
        createWall(-50, wallHeight / 2, 0, Math.PI / 2); // Left wall
        createWall(50, wallHeight / 2, 0, Math.PI / 2);  // Right wall

        // Create targets
        const targets = [];
        function createTarget(x, y, z, team) {
            const geometry = new THREE.CylinderGeometry(3, 3, 0.5, 32);
            const material = new THREE.MeshStandardMaterial({
                color: teams[team].color,
                emissive: teams[team].color,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });
            const target = new THREE.Mesh(geometry, material);
            target.position.set(x, y, z);
            target.rotation.x = Math.PI / 2;
            target.castShadow = true;
            target.receiveShadow = true;
            target.userData = { team, points: 10, type: 'target' };
            scene.add(target);
            targets.push(target);

            // Add glow ring
            const ringGeometry = new THREE.RingGeometry(3.2, 3.5, 32);
            const ringMaterial = new THREE.MeshBasicMaterial({
                color: teams[team].color,
                side: THREE.DoubleSide,
                transparent: true,
                opacity: 0.5
            });
            const ring = new THREE.Mesh(ringGeometry, ringMaterial);
            ring.position.copy(target.position);
            ring.rotation.x = Math.PI / 2;
            scene.add(ring);

            // Animate ring
            ring.userData = {
                update: function(time) {
                    ring.scale.x = 1 + Math.sin(time * 3) * 0.1;
                    ring.scale.y = 1 + Math.sin(time * 3) * 0.1;
                    ring.material.opacity = 0.5 + Math.sin(time * 2) * 0.2;
                }
            };
            targets.push(ring);
        }

        // Place targets
        createTarget(-20, 0.5, -20, 'cardinals');
        createTarget(20, 0.5, -20, 'titans');
        createTarget(-20, 0.5, 20, 'longhorns');
        createTarget(20, 0.5, 20, 'grizzlies');

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 30, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.left = -50;
        directionalLight.shadow.camera.right = 50;
        directionalLight.shadow.camera.top = 50;
        directionalLight.shadow.camera.bottom = -50;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Point lights for team colors
        Object.keys(teams).forEach((team, index) => {
            const angle = (index / 4) * Math.PI * 2;
            const pointLight = new THREE.PointLight(teams[team].color, 0.5, 50);
            pointLight.position.set(
                Math.cos(angle) * 30,
                10,
                Math.sin(angle) * 30
            );
            scene.add(pointLight);
        });

        // Camera positioning
        camera.position.set(0, 40, 60);
        camera.lookAt(0, 0, 0);

        // Ball creation function
        function createBall(team, position, velocity) {
            // Three.js ball
            const geometry = new THREE.SphereGeometry(1, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: teams[team].color,
                emissive: teams[team].color,
                emissiveIntensity: 0.2,
                metalness: 0.6,
                roughness: 0.4
            });
            const ball = new THREE.Mesh(geometry, material);
            ball.position.copy(position);
            ball.castShadow = true;
            ball.receiveShadow = true;
            ball.userData = { team, type: 'ball' };
            scene.add(ball);

            // Physics ball
            const shape = new CANNON.Sphere(1);
            const body = new CANNON.Body({
                mass: 1,
                shape: shape,
                position: new CANNON.Vec3(position.x, position.y, position.z),
                velocity: new CANNON.Vec3(velocity.x, velocity.y, velocity.z)
            });
            world.addBody(body);

            // Add trail effect
            const trailGeometry = new THREE.BufferGeometry();
            const trailPositions = new Float32Array(30 * 3);
            trailGeometry.setAttribute('position', new THREE.BufferAttribute(trailPositions, 3));
            const trailMaterial = new THREE.LineBasicMaterial({
                color: teams[team].color,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            const ballObject = {
                mesh: ball,
                body: body,
                trail: trail,
                trailPositions: [],
                team: team,
                update: function() {
                    // Update mesh position from physics
                    ball.position.copy(body.position);
                    ball.quaternion.copy(body.quaternion);

                    // Update trail
                    this.trailPositions.unshift(ball.position.clone());
                    if (this.trailPositions.length > 10) {
                        this.trailPositions.pop();
                    }

                    const positions = trail.geometry.attributes.position.array;
                    for (let i = 0; i < this.trailPositions.length; i++) {
                        const pos = this.trailPositions[i];
                        positions[i * 3] = pos.x;
                        positions[i * 3 + 1] = pos.y;
                        positions[i * 3 + 2] = pos.z;
                    }
                    trail.geometry.attributes.position.needsUpdate = true;

                    // Remove if out of bounds or stopped
                    if (Math.abs(ball.position.x) > 60 || 
                        Math.abs(ball.position.z) > 60 || 
                        ball.position.y < -10) {
                        this.remove();
                    }
                },
                remove: function() {
                    scene.remove(ball);
                    scene.remove(trail);
                    world.removeBody(body);
                    const index = gameState.activeObjects.indexOf(this);
                    if (index > -1) {
                        gameState.activeObjects.splice(index, 1);
                    }
                }
            };

            gameState.activeObjects.push(ballObject);
            return ballObject;
        }

        // Mouse controls
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        document.addEventListener('mousedown', (event) => {
            gameState.isCharging = true;
            gameState.mouseStart = { x: event.clientX, y: event.clientY };
            gameState.powerLevel = 0;
            
            const powerMeter = document.getElementById('power-meter');
            powerMeter.classList.add('active');
            
            // Hide instructions
            document.getElementById('instructions').classList.add('hidden');
        });

        document.addEventListener('mousemove', (event) => {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (gameState.isCharging && gameState.mouseStart) {
                const dx = event.clientX - gameState.mouseStart.x;
                const dy = event.clientY - gameState.mouseStart.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                gameState.powerLevel = Math.min(distance / 300, 1);
                
                const powerFill = document.getElementById('power-fill');
                powerFill.style.width = (gameState.powerLevel * 100) + '%';
            }
        });

        document.addEventListener('mouseup', (event) => {
            if (gameState.isCharging && gameState.mouseStart) {
                const dx = event.clientX - gameState.mouseStart.x;
                const dy = event.clientY - gameState.mouseStart.y;
                
                // Calculate launch velocity
                const power = gameState.powerLevel * 50;
                const angle = Math.atan2(dy, dx);
                
                const velocity = new THREE.Vector3(
                    -Math.cos(angle) * power,
                    20 + gameState.powerLevel * 20,
                    Math.sin(angle) * power
                );

                // Get spawn position from mouse ray
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObject(floor);
                
                let spawnPos = new THREE.Vector3(0, 5, 0);
                if (intersects.length > 0) {
                    spawnPos = intersects[0].point.clone();
                    spawnPos.y = 5;
                }

                // Cycle through teams
                const teamNames = Object.keys(teams);
                const teamIndex = teamNames.indexOf(gameState.selectedTeam);
                gameState.selectedTeam = teamNames[(teamIndex + 1) % teamNames.length];

                // Create ball
                createBall(teamNames[teamIndex], spawnPos, velocity);
            }

            gameState.isCharging = false;
            gameState.mouseStart = null;
            gameState.powerLevel = 0;
            
            const powerMeter = document.getElementById('power-meter');
            powerMeter.classList.remove('active');
            document.getElementById('power-fill').style.width = '0%';
        });

        // Collision detection
        world.addEventListener('collide', (event) => {
            analytics.collisions++;
            
            // Check for target hits
            gameState.activeObjects.forEach(obj => {
                if (obj.body === event.body) {
                    targets.forEach(target => {
                        if (target.userData.type === 'target') {
                            const distance = obj.mesh.position.distanceTo(target.position);
                            if (distance < 4) {
                                // Score points
                                teams[target.userData.team].score += target.userData.points;
                                updateScores();
                                
                                // Visual feedback
                                target.scale.set(1.5, 1.5, 1.5);
                                setTimeout(() => {
                                    target.scale.set(1, 1, 1);
                                }, 200);
                            }
                        }
                    });
                }
            });
        });

        // Update scores display
        function updateScores() {
            Object.keys(teams).forEach(team => {
                document.getElementById(`${team}-score`).textContent = teams[team].score;
            });
        }

        // Game controls
        function resetGame() {
            gameState.activeObjects.forEach(obj => obj.remove());
            gameState.activeObjects = [];
            Object.keys(teams).forEach(team => {
                teams[team].score = 0;
            });
            updateScores();
        }

        function toggleGravity() {
            gameState.gravityEnabled = !gameState.gravityEnabled;
            world.gravity.set(0, gameState.gravityEnabled ? -9.82 : 0, 0);
        }

        function toggleSlowMotion() {
            gameState.slowMotion = !gameState.slowMotion;
        }

        function spawnPowerUp() {
            const x = (Math.random() - 0.5) * 40;
            const z = (Math.random() - 0.5) * 40;
            const teamNames = Object.keys(teams);
            const randomTeam = teamNames[Math.floor(Math.random() * teamNames.length)];
            
            for (let i = 0; i < 10; i++) {
                const velocity = new THREE.Vector3(
                    (Math.random() - 0.5) * 30,
                    Math.random() * 30 + 10,
                    (Math.random() - 0.5) * 30
                );
                createBall(randomTeam, new THREE.Vector3(x, 10, z), velocity);
            }
        }

        // Animation loop
        const clock = new THREE.Clock();
        let frameCount = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            const deltaTime = clock.getDelta();
            const timeStep = gameState.slowMotion ? deltaTime * 0.3 : deltaTime;
            const elapsedTime = clock.getElapsedTime();
            
            // Update physics
            world.step(timeStep);
            
            // Update game objects
            gameState.activeObjects.forEach(obj => obj.update());
            
            // Update animated targets
            targets.forEach(target => {
                if (target.userData.update) {
                    target.userData.update(elapsedTime);
                }
            });
            
            // Update analytics
            frameCount++;
            if (frameCount % 30 === 0) {
                // Calculate FPS
                const now = performance.now();
                const delta = now - analytics.lastTime;
                analytics.fps = Math.round(1000 / (delta / 30));
                analytics.lastTime = now;
                
                // Calculate physics metrics
                let totalVelocity = 0;
                let totalEnergy = 0;
                
                gameState.activeObjects.forEach(obj => {
                    const vel = obj.body.velocity.length();
                    totalVelocity += vel;
                    totalEnergy += 0.5 * obj.body.mass * vel * vel;
                });
                
                const avgVelocity = gameState.activeObjects.length > 0 ? 
                    totalVelocity / gameState.activeObjects.length : 0;
                
                // Update display
                document.getElementById('active-objects').textContent = gameState.activeObjects.length;
                document.getElementById('collision-rate').textContent = 
                    Math.round(analytics.collisions / (elapsedTime || 1)) + '/s';
                document.getElementById('physics-fps').textContent = analytics.fps;
                document.getElementById('velocity-avg').textContent = avgVelocity.toFixed(1);
                document.getElementById('energy-total').textContent = Math.round(totalEnergy);
                document.getElementById('fps').textContent = analytics.fps;
                document.getElementById('draw-calls').textContent = renderer.info.render.calls;
            }
            
            // Render scene
            renderer.render(scene, camera);
        }
        
        animate();

        // Window resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>