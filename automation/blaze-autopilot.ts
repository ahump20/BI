#!/usr/bin/env -S node --no-warnings --experimental-fetch
/// <reference lib="dom" />
/// <reference types="node" />
/**
 * Blaze Autopilot — "Developer‑Mode" multi-connector orchestrator
 * -----------------------------------------------------------------
 * Single-file TypeScript that lights up a coordinated launch across many services
 * you’ve connected (Cloudflare, Cloudinary, Dropbox, GitHub, Netlify, Notion,
 * Linear, HubSpot, Render, Stripe, Zapier, Box … and more when tokens are present).
 *
 * ⚙️ How to run (minimal):
 *   1) Save as blaze-autopilot.ts
 *   2) `pnpm add -D tsx` (or use npx)
 *   3) Set any relevant env vars (see ENV MAP below).
 *   4) Run: `pnpm tsx blaze-autopilot.ts "My Campaign Name"`
 *
 * This script is idempotent-ish and opportunistic: if a given token isn’t set,
 * that connector is skipped without failing the whole run. Results are summarized
 * at the end so you can see which connectors fired.
 */

// ---------- Utilities --------------------------------------------------------
import crypto from "crypto";
import { setTimeout as sleep } from "timers/promises";

// Node18+ has global fetch / FormData / Blob

type Json = Record<string, any> | any[] | string | number | boolean | null;

const color = {
  dim: (s: string) => `\x1b[2m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  magenta: (s: string) => `\x1b[35m${s}\x1b[0m`,
  bold: (s: string) => `\x1b[1m${s}\x1b[0m`,
};

function env(name: string, required = false): string | undefined {
  const v = process.env[name];
  if (required && !v) throw new Error(`Missing env ${name}`);
  return v?.trim() || undefined;
}

async function jsonFetch<T = any>(url: string, init: RequestInit = {}): Promise<T> {
  const res = await fetch(url, init);
  const text = await res.text();
  let data: any;
  try { data = text ? JSON.parse(text) : {}; } catch { data = text; }
  if (!res.ok) {
    const err = new Error(`HTTP ${res.status} for ${url}: ${typeof data === 'string' ? data : JSON.stringify(data)}`);
    (err as any).status = res.status;
    throw err;
  }
  return data as T;
}

async function withRetries<T>(label: string, fn: () => Promise<T>, retries = 2, baseMs = 400): Promise<T> {
  let attempt = 0, lastErr: any;
  while (attempt <= retries) {
    try { return await fn(); } catch (e: any) {
      lastErr = e;
      if (attempt === retries) break;
      const jitter = Math.floor(Math.random() * baseMs);
      const wait = baseMs * Math.pow(2, attempt) + jitter;
      console.log(color.yellow(`↻ retry ${label} in ${wait}ms (${e?.message || e})`));
      await sleep(wait);
      attempt++;
    }
  }
  throw lastErr;
}

// ---------- Campaign context -------------------------------------------------
interface Campaign {
  name: string;
  slug: string;
  description: string;
  priceCents: number;
  successUrl?: string;
  cancelUrl?: string;
}

interface RunCtx {
  campaign: Campaign;
  memo: Record<string, any>; // cross-connector scratchpad
}

interface ConnectorResult {
  name: string;
  ok: boolean;
  meta?: any;
  error?: string;
}

interface Connector {
  name: string;
  enabled(): boolean;
  run(ctx: RunCtx): Promise<ConnectorResult>;
}

function slugify(s: string) {
  return s.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/(^-|-$)/g, "");
}

// ---------- Connectors ------------------------------------------------------

// 1) GitHub — create a public Gist with campaign briefing (easy + visible)
const GitHub: Connector = {
  name: "GitHub:Gist",
  enabled: () => !!env("GITHUB_TOKEN"),
  async run(ctx) {
    const token = env("GITHUB_TOKEN", true)!;
    const body = {
      description: `Blaze Autopilot — ${ctx.campaign.name}`,
      public: true,
      files: {
        [`${ctx.campaign.slug}.md`]: {
          content: `# ${ctx.campaign.name}\n\n${ctx.campaign.description}\n\n— generated by Blaze Autopilot at ${new Date().toISOString()}`,
        },
      },
    };
    const data = await withRetries(this.name, () => jsonFetch("https://api.github.com/gists", {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}", "Content-Type": "application/json", "Accept": "application/vnd.github+json" },
      body: JSON.stringify(body),
    }));
    ctx.memo.gistUrl = data?.html_url;
    return { name: this.name, ok: true, meta: { url: data?.html_url } };
  },
};

// 2) Netlify — trigger a build hook (fast + reliable)
const Netlify: Connector = {
  name: "Netlify:BuildHook",
  enabled: () => !!env("NETLIFY_BUILD_HOOK_URL"),
  async run(ctx) {
    const url = env("NETLIFY_BUILD_HOOK_URL", true)!;
    const data = await withRetries(this.name, () => jsonFetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ trigger_title: `Blaze Autopilot: ${ctx.campaign.name}`, campaign: ctx.campaign }),
    }));
    return { name: this.name, ok: true, meta: data };
  },
};

// 3) Cloudflare — purge cache for a zone (post‑deploy hygiene)
const Cloudflare: Connector = {
  name: "Cloudflare:PurgeCache",
  enabled: () => !!env("CLOUDFLARE_TOKEN") && !!env("CLOUDFLARE_ZONE_ID"),
  async run(ctx) {
    const token = env("CLOUDFLARE_TOKEN", true)!;
    const zoneId = env("CLOUDFLARE_ZONE_ID", true)!;
    const data = await withRetries(this.name, () => jsonFetch(`https://api.cloudflare.com/client/v4/zones/${zoneId}/purge_cache`, {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}", "Content-Type": "application/json" },
      body: JSON.stringify({ purge_everything: true }),
    }));
    return { name: this.name, ok: true, meta: data };
  },
};

// 4) Cloudinary — upload a simple campaign poster (signed upload)
const Cloudinary: Connector = {
  name: "Cloudinary:Upload",
  enabled: () => !!env("CLOUDINARY_CLOUD_NAME") && !!env("CLOUDINARY_API_KEY") && !!env("CLOUDINARY_API_SECRET"),
  async run(ctx) {
    const cloud = env("CLOUDINARY_CLOUD_NAME", true)!;
    const key = env("CLOUDINARY_API_KEY", true)!;
    const secret = env("CLOUDINARY_API_SECRET", true)!;
    const publicId = `blaze/${ctx.campaign.slug}-${Date.now()}`;
    const timestamp = Math.floor(Date.now() / 1000);
    const toSign = `public_id=${publicId}&timestamp=${timestamp}`;
    const signature = crypto.createHash("sha1").update(toSign + secret).digest("hex");

    // tiny SVG poster as a Blob
    const svg = `<svg xmlns='http://www.w3.org/2000/svg' width='1200' height='630'>
      <rect width='100%' height='100%' fill='black'/>
      <text x='50%' y='50%' font-family='monospace' font-size='48' fill='white' text-anchor='middle'>${ctx.campaign.name}</text>
      <text x='50%' y='60%' font-family='monospace' font-size='20' fill='#999' text-anchor='middle'>${ctx.campaign.slug}</text>
    </svg>`;
    const file = new Blob([svg], { type: "image/svg+xml" });

    const form = new FormData();
    form.set("file", file, `${ctx.campaign.slug}.svg`);
    form.set("api_key", key);
    form.set("timestamp", String(timestamp));
    form.set("public_id", publicId);
    form.set("signature", signature);

    const res = await withRetries(this.name, async () => {
      const r = await fetch(`https://api.cloudinary.com/v1_1/${cloud}/image/upload`, { method: "POST", body: form as any });
      if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
      return r.json();
    });

    ctx.memo.cloudinary = { publicId, url: res.secure_url };
    return { name: this.name, ok: true, meta: { url: res.secure_url } };
  },
};

// 5) Dropbox — upload campaign brief as text
const Dropbox: Connector = {
  name: "Dropbox:Upload",
  enabled: () => !!env("DROPBOX_TOKEN"),
  async run(ctx) {
    const token = env("DROPBOX_TOKEN", true)!;
    const path = `/Blaze/${ctx.campaign.slug}.txt`;
    const content = `Campaign: ${ctx.campaign.name}\nSlug: ${ctx.campaign.slug}\nGenerated: ${new Date().toISOString()}\n`;
    const r = await withRetries(this.name, () => fetch("https://content.dropboxapi.com/2/files/upload", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Dropbox-API-Arg": JSON.stringify({ path, mode: "add", autorename: true, mute: false }),
        "Content-Type": "application/octet-stream",
      },
      body: Buffer.from(content),
    }));
    if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
    const data = await r.json();
    return { name: this.name, ok: true, meta: { path: data?.path_display } };
  },
};

// 6) Box — upload the same brief
const Box: Connector = {
  name: "Box:Upload",
  enabled: () => !!env("BOX_TOKEN") && !!env("BOX_FOLDER_ID"),
  async run(ctx) {
    const token = env("BOX_TOKEN", true)!;
    const folderId = env("BOX_FOLDER_ID", true)!;
    const form = new FormData();
    form.set("attributes", JSON.stringify({ name: `${ctx.campaign.slug}.txt`, parent: { id: folderId } }));
    form.set("file", new Blob([`Blaze brief for ${ctx.campaign.name}`], { type: "text/plain" }), `${ctx.campaign.slug}.txt`);
    const r = await withRetries(this.name, () => fetch("https://upload.box.com/api/2.0/files/content", {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}` },
      body: form as any,
    }));
    if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
    const data = await r.json();
    return { name: this.name, ok: true, meta: { id: data?.entries?.[0]?.id } };
  },
};

// 7) Notion — create a page in a database
const Notion: Connector = {
  name: "Notion:CreatePage",
  enabled: () => !!env("NOTION_TOKEN") && !!env("NOTION_DATABASE_ID"),
  async run(ctx) {
    const token = env("NOTION_TOKEN", true)!;
    const db = env("NOTION_DATABASE_ID", true)!;
    const stripe = ctx.memo.stripe ?? {};

    const page = await withRetries(this.name, () => jsonFetch("https://api.notion.com/v1/pages", {
      method: "POST",
      headers: {
        "Authorization": `Bearer ${token}`,
        "Content-Type": "application/json",
        "Notion-Version": "2022-06-28",
      },
      body: JSON.stringify({
        parent: { database_id: db },
        properties: {
          Name: { title: [{ text: { content: ctx.campaign.name } }] },
          Slug: { rich_text: [{ text: { content: ctx.campaign.slug } }] },
          Price: { number: ctx.campaign.priceCents / 100 },
          Checkout: stripe?.checkoutUrl ? { url: stripe.checkoutUrl } : undefined,
        },
      }),
    }));

    return { name: this.name, ok: true, meta: { id: page?.id } };
  },
};

// 8) HubSpot — create (or upsert-ish) a contact placeholder for the campaign
const HubSpot: Connector = {
  name: "HubSpot:CreateContact",
  enabled: () => !!env("HUBSPOT_TOKEN"),
  async run(ctx) {
    const token = env("HUBSPOT_TOKEN", true)!;
    const email = `autopilot+${ctx.campaign.slug}@example.local`;
    const data = await withRetries(this.name, () => jsonFetch("https://api.hubapi.com/crm/v3/objects/contacts", {
      method: "POST",
      headers: { "Authorization": `Bearer ${token}`, "Content-Type": "application/json" },
      body: JSON.stringify({ properties: { email, firstname: "Blaze", lastname: "Autopilot", lifecyclestage: "opportunity" } }),
    }));
    return { name: this.name, ok: true, meta: { id: data?.id, email } };
  },
};

// 9) Linear — create an issue for the workstream
const Linear: Connector = {
  name: "Linear:CreateIssue",
  enabled: () => !!env("LINEAR_TOKEN") && !!env("LINEAR_TEAM_ID"),
  async run(ctx) {
    const token = env("LINEAR_TOKEN", true)!;
    const teamId = env("LINEAR_TEAM_ID", true)!; // Use team ID (not key)
    const query = `mutation($input: IssueCreateInput!) { issueCreate(input: $input) { success issue { id identifier url } } }`;
    const variables = {
      input: {
        teamId,
        title: `Launch: ${ctx.campaign.name}`,
        description: `Autocreated by Blaze Autopilot at ${new Date().toISOString()}`,
      },
    };
    const data = await withRetries(this.name, () => jsonFetch("https://api.linear.app/graphql", {
      method: "POST",
      headers: { "Content-Type": "application/json", "Authorization": env("LINEAR_TOKEN", true)! },
      body: JSON.stringify({ query, variables }),
    }));
    const issue = data?.data?.issueCreate?.issue;
    return { name: this.name, ok: true, meta: { id: issue?.id, url: issue?.url } };
  },
};

// 10) Render — trigger a deploy for a service
const Render: Connector = {
  name: "Render:Deploy",
  enabled: () => !!env("RENDER_API_KEY") && !!env("RENDER_SERVICE_ID"),
  async run(ctx) {
    const key = env("RENDER_API_KEY", true)!;
    const id = env("RENDER_SERVICE_ID", true)!;
    const data = await withRetries(this.name, () => jsonFetch(`https://api.render.com/v1/services/${id}/deploys`, {
      method: "POST",
      headers: { "Authorization": `Bearer ${key}`, "Content-Type": "application/json" },
      body: JSON.stringify({ clearCache: true, triggerReason: `Blaze Autopilot: ${ctx.campaign.name}` }),
    }));
    return { name: this.name, ok: true, meta: { deployId: data?.id, status: data?.status } };
  },
};

// 11) Stripe — product, price, and checkout session
const StripeConn: Connector = {
  name: "Stripe:Checkout",
  enabled: () => !!env("STRIPE_SECRET_KEY"),
  async run(ctx) {
    const key = env("STRIPE_SECRET_KEY", true)!;
    const enc = (o: Record<string, string>) => new URLSearchParams(o).toString();

    const product = await withRetries("Stripe:product", async () => {
      const r = await fetch("https://api.stripe.com/v1/products", {
        method: "POST",
        headers: { "Authorization": `Bearer ${key}`, "Content-Type": "application/x-www-form-urlencoded" },
        body: enc({ name: ctx.campaign.name, description: ctx.campaign.description }),
      });
      if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
      return r.json();
    });

    const price = await withRetries("Stripe:price", async () => {
      const r = await fetch("https://api.stripe.com/v1/prices", {
        method: "POST",
        headers: { "Authorization": `Bearer ${key}`, "Content-Type": "application/x-www-form-urlencoded" },
        body: enc({ unit_amount: String(ctx.campaign.priceCents), currency: "usd", product: product.id }),
      });
      if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
      return r.json();
    });

    const successUrl = ctx.campaign.successUrl || "https://example.com/success";
    const cancelUrl = ctx.campaign.cancelUrl || "https://example.com/cancel";

    const checkout = await withRetries("Stripe:checkout", async () => {
      const r = await fetch("https://api.stripe.com/v1/checkout/sessions", {
        method: "POST",
        headers: { "Authorization": `Bearer ${key}`, "Content-Type": "application/x-www-form-urlencoded" },
        body: enc({ mode: "payment", "line_items[0][price]": price.id, "line_items[0][quantity]": "1", success_url: successUrl, cancel_url: cancelUrl }),
      });
      if (!r.ok) throw new Error(`${r.status} ${await r.text()}`);
      return r.json();
    });

    ctx.memo.stripe = { productId: product.id, priceId: price.id, checkoutUrl: checkout.url };
    return { name: this.name, ok: true, meta: ctx.memo.stripe };
  },
};

// 12) Zapier — broadcast a webhook with the summary payload
const Zapier: Connector = {
  name: "Zapier:Webhook",
  enabled: () => !!env("ZAPIER_WEBHOOK_URL"),
  async run(ctx) {
    const url = env("ZAPIER_WEBHOOK_URL", true)!;
    const payload = { campaign: ctx.campaign, memo: ctx.memo };
    const res = await withRetries(this.name, () => jsonFetch(url, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(payload),
    }));
    return { name: this.name, ok: true, meta: res };
  },
};

// ---------- Optional / TODO stubs (OAuth-heavy) ------------------------------
// Gmail, Google Calendar/Contacts/Drive, Canva, Invideo require OAuth flows or
// dedicated SDKs; hook them in here if you already have access tokens.

// ---------- Orchestrator -----------------------------------------------------
const CONNECTORS: Connector[] = [
  StripeConn,       // create monetization primitives early
  GitHub,
  Notion,
  Linear,
  HubSpot,
  Cloudinary,
  Dropbox,
  Box,
  Netlify,
  Render,
  Cloudflare,
  Zapier,
];

async function runAll(ctx: RunCtx): Promise<ConnectorResult[]> {
  // Run in waves to allow light dependency (Stripe first → Notion can capture checkout URL)
  const waves: Connector[][] = [
    [StripeConn],
    [GitHub, Notion, Linear, HubSpot, Cloudinary],
    [Dropbox, Box],
    [Netlify, Render, Cloudflare, Zapier],
  ];

  const results: ConnectorResult[] = [];
  for (const wave of waves) {
    const active = wave.filter(c => c.enabled());
    if (!active.length) continue;
    console.log("\n" + color.bold(color.cyan(`▶ Wave ${waves.indexOf(wave)+1}/${waves.length}`)), color.gray(`(${active.map(a=>a.name).join(", ")})`));
    const settled = await Promise.allSettled(active.map(c =>
      withRetries(c.name, () => c.run(ctx), 1).then(meta => ({ ...meta, name: c.name, ok: true }))
    ));
    for (const s of settled) {
      if (s.status === "fulfilled") {
        const r = s.value as ConnectorResult;
        results.push(r);
        console.log("  ", color.green("✔"), r.name, r.meta ? color.dim(JSON.stringify(r.meta)) : "");
      } else {
        const err = s.reason as Error;
        results.push({ name: (err as any)?.name || "unknown", ok: false, error: err?.message || String(err) });
        console.log("  ", color.red("✖"), err?.message || s.reason);
      }
    }
  }
  return results;
}

function parseArgs(): Campaign {
  const name = process.argv.slice(2).join(" ") || `Blaze Drop ${new Date().toISOString().slice(0,10)}`;
  const slug = slugify(name);
  const description = `Autogenerated launch pack for ${name}.`;
  const priceCents = Number(process.env.PRICE_CENTS || 2500);
  return { name, slug, description, priceCents };
}

async function main() {
  const campaign = parseArgs();
  const ctx: RunCtx = { campaign, memo: {} };
  console.log(color.bold(`\nBlaze Autopilot — ${campaign.name}`), color.gray(`(${campaign.slug})`));

  const enabled = CONNECTORS.filter(c => c.enabled());
  if (!enabled.length) {
    console.log(color.red("No connectors enabled via env. See ENV MAP below."));
    process.exit(1);
  }

  const results = await runAll(ctx);
  const ok = results.filter(r => r.ok).length;
  const fail = results.length - ok;

  // Pretty summary
  console.log("\n" + color.bold("Summary:"));
  for (const r of results) {
    console.log(` - ${r.ok ? color.green("✔") : color.red("✖")} ${r.name}`);
  }
  console.log(`\n${color.bold("Done")} — ${ok} succeeded, ${fail} failed.`);
  if (ctx.memo.gistUrl) console.log("Gist:", color.cyan(ctx.memo.gistUrl));
  if (ctx.memo?.stripe?.checkoutUrl) console.log("Checkout:", color.cyan(ctx.memo.stripe.checkoutUrl));
  if (ctx.memo?.cloudinary?.url) console.log("Poster:", color.cyan(ctx.memo.cloudinary.url));
}

main().catch(e => { console.error(color.red(String(e?.stack || e))); process.exit(1); });

/*
ENV MAP (set what you have — others will be skipped):
  # GitHub
  GITHUB_TOKEN=ghp_xxx

  # Netlify
  NETLIFY_BUILD_HOOK_URL=https://api.netlify.com/build_hooks/xxx

  # Cloudflare
  CLOUDFLARE_TOKEN=cf_xxx
  CLOUDFLARE_ZONE_ID=abcd1234

  # Cloudinary
  CLOUDINARY_CLOUD_NAME=your_cloud
  CLOUDINARY_API_KEY=12345
  CLOUDINARY_API_SECRET=abcde

  # Dropbox
  DROPBOX_TOKEN=sl.BC-xxx

  # Box
  BOX_TOKEN=box_xxx
  BOX_FOLDER_ID=123456789

  # Notion
  NOTION_TOKEN=secret_xxx
  NOTION_DATABASE_ID=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx

  # HubSpot
  HUBSPOT_TOKEN=pat-xxx

  # Linear
  LINEAR_TOKEN=lin_xxx
  LINEAR_TEAM_ID=uuid-of-team

  # Render
  RENDER_API_KEY=rv_xxx
  RENDER_SERVICE_ID=svc-xxx

  # Stripe
  STRIPE_SECRET_KEY=sk_live_...
  PRICE_CENTS=2500

  # Zapier
  ZAPIER_WEBHOOK_URL=https://hooks.zapier.com/hooks/catch/xxx/yyy

Notes:
 - Gmail / Google Calendar / Contacts / Drive / Canva / Invideo typically require OAuth flows; wire them in where noted if you have tokens.
 - This file is purposely dependency-light (uses global fetch). For production, swap to official SDKs and add persistence + idempotency keys.
*/
